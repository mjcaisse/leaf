<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="generator" content="Asciidoctor 2.0.10">
<meta name="author" content="Lightweight Error Augmentation Framework">
<title>LEAF</title>
<link rel="stylesheet" href="./zajo-dark.css">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css">
<meta name="keywords" content="c++,error handling,open source">
<meta name="description" content="Lightweight Error Augmentation Framework">
<link rel="stylesheet" href="./zajo-light.css" disabled=true>
<script>
function switch_style()
{
	var i, tag;
	for( i=0, tag=document.getElementsByTagName("link"); i<tag.length; i++ )
		if( tag[i].rel.indexOf("stylesheet")!=-1 && tag[i].href.includes("zajo-") )
			tag[i].disabled = !tag[i].disabled;
}
</script>
</head>
<body class="article toc2 toc-left">
<div id="header">
<h1>LEAF</h1>
<div class="details">
<span id="author" class="author">Lightweight Error Augmentation Framework</span><br>
</div>
<div id="toc" class="toc2">
<div id="toctitle"><div style="float:right"><input width="32" height="32" type="image" alt="Skin" src="./skin.png" onclick="this.blur();switch_style();return false;"/></div></div>
<ul class="sectlevel1">
<li><a href="#_abstract">Abstract</a></li>
<li><a href="#introduction">Five Minute Introduction</a>
<ul class="sectlevel2">
<li><a href="#introduction-result">Using <code>result&lt;T&gt;</code></a></li>
<li><a href="#introduction-eh">Using Exception Handling</a></li>
</ul>
</li>
<li><a href="#tutorial">Tutorial</a>
<ul class="sectlevel2">
<li><a href="#tutorial-definitions">Definitions</a></li>
<li><a href="#tutorial-model">Error Communication Model</a>
<ul class="sectlevel3">
<li><a href="#_using_noexcept_functionality">Using <code>noexcept</code> Functionality</a></li>
<li><a href="#_using_exception_handling">Using Exception Handling</a></li>
<li><a href="#tutorial-interoperability">Interoperability</a></li>
</ul>
</li>
<li><a href="#tutorial-is_e_type">E-types</a></li>
<li><a href="#tutorial-context_deduction">Automatic Deduction of <code>context</code> Types</a></li>
<li><a href="#tutorial-loading">Loading</a></li>
<li><a href="#tutorial-accumulation">Accumulation</a></li>
<li><a href="#tutorial-preload">Using <code>preload</code></a></li>
<li><a href="#tutorial-defer">Capturing <code>errno</code> with <code>defer</code></a></li>
<li><a href="#tutorial-accumulate">Deferred <code>accumulate</code></a></li>
<li><a href="#tutorial-remote_handlers">Working with Remote Handlers</a></li>
<li><a href="#tutorial-async">Transporting Error Objects Between Threads</a>
<ul class="sectlevel3">
<li><a href="#tutorial-async_result">Using <code>result&lt;T&gt;</code></a></li>
<li><a href="#tutorial-async_eh">Using Exception Handling</a></li>
</ul>
</li>
<li><a href="#tutorial-disparate_error_types">Working with Disparate Error Types</a></li>
<li><a href="#tutorial-exception_to_result">Converting Exceptions to <code>result&lt;T&gt;</code></a></li>
<li><a href="#tutorial-preload_in_c_callbacks">Using <code>augment_id</code> in (Lua) C-callbacks</a></li>
<li><a href="#tutorial-diagnostic_information">Diagnostic Information</a></li>
</ul>
</li>
<li><a href="#examples">Examples</a></li>
<li><a href="#synopsis">Synopsis</a>
<ul class="sectlevel2">
<li><a href="#synopsis-reporting">Error Reporting</a>
<ul class="sectlevel3">
<li><a href="#error.hpp"><code>error.hpp</code></a></li>
<li><a href="#common.hpp"><code>common.hpp</code></a></li>
<li><a href="#result.hpp"><code>result.hpp</code></a></li>
<li><a href="#preload.hpp"><code>preload.hpp</code></a></li>
<li><a href="#exception.hpp"><code>exception.hpp</code></a></li>
<li><a href="#_capture_hpp"><code>capture.hpp</code></a></li>
</ul>
</li>
<li><a href="#tutorial-handling">Error Handling</a>
<ul class="sectlevel3">
<li><a href="#context.hpp"><code>context.hpp</code></a></li>
<li><a href="#handle_error.hpp"><code>handle_error.hpp</code></a></li>
<li><a href="#handle_exception.hpp"><code>handle_exception.hpp</code></a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#traits">Reference: Traits</a>
<ul class="sectlevel2">
<li><a href="#is_e_type"><code>is_e_type</code></a></li>
<li><a href="#is_result_type"><code>is_result_type</code></a></li>
</ul>
</li>
<li><a href="#functions">Reference: Functions</a>
<ul class="sectlevel2">
<li><a href="#accumulate"><code>accumulate</code></a></li>
<li><a href="#activate_context"><code>activate_context</code></a></li>
<li><a href="#allocate_shared_context"><code>allocate_shared_context</code></a></li>
<li><a href="#capture"><code>capture</code></a></li>
<li><a href="#context_type_from_remote_handler"><code>context_type_from_remote_handler</code></a></li>
<li><a href="#current_error"><code>current_error</code></a></li>
<li><a href="#defer"><code>defer</code></a></li>
<li><a href="#exception"><code>exception</code></a></li>
<li><a href="#exception_to_result"><code>exception_to_result</code></a></li>
<li><a href="#make_context"><code>make_context</code></a></li>
<li><a href="#make_shared_context"><code>make_shared_context</code></a></li>
<li><a href="#new_error"><code>new_error</code></a></li>
<li><a href="#preload"><code>preload</code></a></li>
<li><a href="#remote_try_catch"><code>remote_try_catch</code></a></li>
<li><a href="#remote_try_handle_all"><code>remote_try_handle_all</code></a></li>
<li><a href="#remote_try_handle_some"><code>remote_try_handle_some</code></a></li>
<li><a href="#try_catch"><code>try_catch</code></a></li>
<li><a href="#try_handle_all"><code>try_handle_all</code></a></li>
<li><a href="#try_handle_some"><code>try_handle_some</code></a></li>
</ul>
</li>
<li><a href="#types">Reference: Types</a>
<ul class="sectlevel2">
<li><a href="#augment_id"><code>augment_id</code></a></li>
<li><a href="#catch_"><code>catch_</code></a></li>
<li><a href="#condition"><code>condition</code></a></li>
<li><a href="#context"><code>context</code></a>
<ul class="sectlevel3">
<li><a href="#context::context">Constructors</a></li>
<li><a href="#context::activate"><code>activate</code></a></li>
<li><a href="#context::deactivate"><code>deactivate</code></a></li>
<li><a href="#context::handle_error"><code>handle_error</code></a></li>
<li><a href="#context::is_active"><code>is_active</code></a></li>
<li><a href="#context::print"><code>print</code></a></li>
<li><a href="#context::propagate"><code>propagate</code></a></li>
<li><a href="#context::remote_handle_error"><code>remote_handle_error</code></a></li>
</ul>
</li>
<li><a href="#context_activator"><code>context_activator</code></a></li>
<li><a href="#diagnostic_info"><code>diagnostic_info</code></a></li>
<li><a href="#error_id"><code>error_id</code></a>
<ul class="sectlevel3">
<li><a href="#error_id::error_id">Constructors</a></li>
<li><a href="#error_id::accumulate"><code>accumulate</code></a></li>
<li><a href="#is_error_id"><code>is_error_id</code></a></li>
<li><a href="#error_id::load"><code>load</code></a></li>
<li><a href="#error_id::comparison_operators"><code>operator==</code>, <code>!=</code>, <code>&lt;</code></a></li>
<li><a href="#error_id::operator_bool"><code>operator bool</code></a></li>
<li><a href="#error_id::to_error_code"><code>to_error_code</code></a></li>
<li><a href="#error_id::value"><code>value</code></a></li>
</ul>
</li>
<li><a href="#e_api_function"><code>e_api_function</code></a></li>
<li><a href="#e_at_line"><code>e_at_line</code></a></li>
<li><a href="#e_errno"><code>e_errno</code></a></li>
<li><a href="#e_file_name"><code>e_file_name</code></a></li>
<li><a href="#e_LastError"><code>e_LastError</code></a></li>
<li><a href="#e_source_location"><code>e_source_location</code></a></li>
<li><a href="#e_type_info_name"><code>e_type_info_name</code></a></li>
<li><a href="#error_info"><code>error_info</code></a></li>
<li><a href="#match"><code>match</code></a></li>
<li><a href="#polymorphic_context"><code>polymorphic_context</code></a></li>
<li><a href="#result"><code>result</code></a>
<ul class="sectlevel3">
<li><a href="#result::result">Constructors</a></li>
<li><a href="#result::accumulate"><code>accumulate</code></a></li>
<li><a href="#result::error"><code>error</code></a></li>
<li><a href="#result::load"><code>load</code></a></li>
<li><a href="#result::operator_eq"><code>operator=</code></a></li>
<li><a href="#result::operator_bool"><code>operator bool</code></a></li>
<li><a href="#result::value"><code>value</code> / <code>operator*</code> / <code>operator-></code></a></li>
</ul>
</li>
<li><a href="#verbose_diagnostic_info"><code>verbose_diagnostic_info</code></a></li>
</ul>
</li>
<li><a href="#macros">Reference: Macros</a>
<ul class="sectlevel2">
<li><a href="#LEAF_AUTO"><code>LEAF_AUTO</code></a></li>
<li><a href="#LEAF_CHECK"><code>LEAF_CHECK</code></a></li>
<li><a href="#LEAF_NEW_ERROR"><code>LEAF_NEW_ERROR</code></a></li>
<li><a href="#LEAF_EXCEPTION"><code>LEAF_EXCEPTION</code></a></li>
<li><a href="#LEAF_THROW"><code>LEAF_THROW</code></a></li>
</ul>
</li>
<li><a href="#rationale">Design</a>
<ul class="sectlevel2">
<li><a href="#_rationale">Rationale</a></li>
<li><a href="#exception_specifications">Critique 1: Error Types Do Not Participate in Function Signatures</a></li>
<li><a href="#translation">Critique 2: LEAF Does Not Facilitate Mapping Between Different Error Types</a></li>
<li><a href="#errors_are_not_implementation_details">Critique 3: LEAF Does Not Treat Low Level Error Types as Implementation Details</a></li>
</ul>
</li>
<li><a href="#_alternatives_to_leaf">Alternatives to LEAF</a>
<ul class="sectlevel2">
<li><a href="#boost_exception">Comparison to Boost Exception</a></li>
<li><a href="#boost_outcome">Comparison to Boost Outcome</a>
<ul class="sectlevel3">
<li><a href="#_design_differences">Design Differences</a></li>
<li><a href="#interoperability">The Interoperability Problem</a></li>
<li><a href="#_benchmark">Benchmark</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#distribution">Distribution</a></li>
<li><a href="#portability">Portability</a></li>
<li><a href="#building">Building</a></li>
<li><a href="#_configuration_macros">Configuration Macros</a></li>
<li><a href="#_acknowledgements">Acknowledgements</a></li>
</ul>
</div>
</div>
<div id="content">
<div id="preamble">
<div class="sectionbody">
<div class="paragraph text-right">
<p><a href="https://github.com/zajo/leaf">GitHub</a> | <a href="https://travis-ci.org/zajo/leaf">Travis</a> | <a href="https://ci.appveyor.com/project/zajo/leaf">AppVeyor</a> | <a href="./leaf.pdf">PDF</a></p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_abstract">Abstract</h2>
<div class="sectionbody">
<div class="paragraph">
<p>LEAF is a lightweight error handling library for C&#43;&#43;11. Features:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="ulist">
<ul>
<li>
<p>Efficient delivery of arbitrary error objects to the correct error-handling scope.</p>
</li>
<li>
<p>No dynamic memory allocations.</p>
</li>
<li>
<p>Compatible with <code>std::error_code</code>, <code>errno</code> and any other error code type.</p>
</li>
<li>
<p>Can be used with or without exception handling.</p>
</li>
<li>
<p>Support for multi-thread programming.</p>
</li>
</ul>
</div>
</div>
</div>
<table class="tableblock frame-none grid-none stretch">
<colgroup>
<col style="width: 50%;">
<col style="width: 50%;">
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#introduction">Introduction</a> | <a href="#tutorial">Tutorial</a> | <a href="#synopsis">Synopsis</a> | <a href="https://github.com/zajo/leaf/blob/master/doc/whitepaper.md">Whitepaper</a> | <a href="https://github.com/zajo/leaf/blob/master/benchmark/benchmark.md">Benchmark</a></p></td>
<td class="tableblock halign-right valign-top"><p class="tableblock">Reference: <a href="#functions">Functions</a> | <a href="#types">Types</a> | <a href="#traits">Traits</a> | <a href="#macros">Macros</a></p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>LEAF is designed with a strong bias towards the common use case where callers of functions which may fail check for success and forward errors up the call chain but do not handle them. When a function fails, the only data transported in the <code>leaf::result&lt;T&gt;</code> object is a simple discriminant. In this case, LEAF does not bother to make the actual error object(s) available to the caller. This saves a lot of cycles and results in very efficient code.</p>
</div>
<div class="paragraph">
<p>If the caller wants to handle at least some failures, this intention must be explicitly expressed by a call to <code>try_handle_some</code>. This instructs LEAF to deliver relevant error objects to this scope, so the program can inspect them and possibly restore normal operation. If we want to handle all, rather than only some failures, this is expressed by a call to <code>try_handle_all</code>. In this case, LEAF ensures (statically, at compile time) that the user provides suitable handlers for all failures.</p>
</div>
<div class="paragraph">
<p>Regardless of whether we call <code>try_handle_some</code>, <code>try_handle_all</code>, or the exception-handling alternative <code>try_catch</code>, LEAF reserves memory on the stack, suitable for storage of error objects based on the static types of the arguments of the provided error handlers. No dynamic memory allocations occur, even when working with extremely large error objects.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="introduction">Five Minute Introduction</h2>
<div class="sectionbody">
<div class="paragraph">
<p>We&#8217;ll implement two versions of the same simple program: one using error codes to handle errors, and one using exception handling.</p>
</div>
<div class="sect2">
<h3 id="introduction-result">Using <code>result&lt;T&gt;</code></h3>
<div class="paragraph">
<p>We&#8217;ll write a short but complete program that reads a text file in a buffer and prints it to <code>std::cout</code>, using LEAF to handle errors without exception handling.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
This part of the introduction is about using LEAF without exception handling. LEAF works great <a href="#introduction-eh">Using Exception Handling</a> as well.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Let&#8217;s jump ahead and start with the <code>main</code> function: it will try several operations as needed and handle all the errors that occur. Did I say <strong>all</strong> the errors? I did, so we&#8217;ll use <code>leaf::try_handle_all</code>. It has the following signature:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight nowrap"><code class="language-c++" data-lang="c++">template &lt;class TryBlock, class... Handler&gt;
&lt;&lt;deduced-type&gt;&gt; try_handle_all( TryBlock &amp;&amp; try_block, Handler &amp;&amp; ... handler );</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>TryBlock</code> is a function type, almost always a lambda. It is required to return a <code>result&lt;T&gt;</code> type&#8201;&#8212;&#8201;for example, <code>leaf::result&lt;T&gt;</code>&#8201;&#8212;&#8201;that holds a value of type <code>T</code> or else it indicates a failure.</p>
</div>
<div class="paragraph">
<p>The first thing <code>try_handle_all</code> does is invoke the <code>try_block</code> function. If the returned object <code>r</code> indicates success, <code>try_handle_all</code> returns the contained <code>r.value()</code>; otherwise it calls the first suitable error handling function from the <code>handler&#8230;&#8203;</code> list.</p>
</div>
<div class="paragraph">
<p>We&#8217;ll see later just what kind of a <code>TryBlock</code> will our <code>main</code> function pass to <code>try_handle_all</code>, but first, let&#8217;s look at the juicy error-handling part. LEAF will consider each of the <code>handler&#8230;&#8203;</code> lambdas, in order, and call the first suitable match:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight nowrap"><code class="language-c++" data-lang="c++">int main( int argc, char const * argv[] )
{
  return leaf::try_handle_all(

    [&amp;]() -&gt; leaf::result&lt;int&gt;
    {
      // The TryBlock code goes here, we'll see it later
    },

    [](leaf::match&lt;error_code, input_file_open_error&gt;, <i class="conum" data-value="1"></i><b>(1)</b>
        leaf::match&lt;leaf::e_errno, ENOENT&gt;,
        leaf::e_file_name const &amp; fn)
    {
      std::cerr &lt;&lt; "File not found: " &lt;&lt; fn.value &lt;&lt; std::endl;
      return 1;
    },

    [](leaf::match&lt;error_code, input_file_open_error&gt;, <i class="conum" data-value="2"></i><b>(2)</b>
        leaf::e_errno const &amp; errn,
        leaf::e_file_name const &amp; fn)
    {
      std::cerr &lt;&lt; "Failed to open " &lt;&lt; fn.value &lt;&lt; ", errno=" &lt;&lt; errn &lt;&lt; std::endl;
      return 2;
    },

    [](leaf::match&lt;error_code, input_file_size_error, input_file_read_error, input_eof_error&gt;, <i class="conum" data-value="3"></i><b>(3)</b>
        leaf::e_errno const &amp; errn,
        leaf::e_file_name const &amp; fn)
    {
      std::cerr &lt;&lt; "Failed to access " &lt;&lt; fn.value &lt;&lt; ", errno=" &lt;&lt; errn &lt;&lt; std::endl;
      return 3;
    },

    [](leaf::match&lt;error_code, cout_error&gt;, <i class="conum" data-value="4"></i><b>(4)</b>
        leaf::e_errno const &amp; errn)
    {
      std::cerr &lt;&lt; "Output error, errno=" &lt;&lt; errn &lt;&lt; std::endl;
      return 4;
    },

    [](leaf::match&lt;error_code, bad_command_line&gt;) <i class="conum" data-value="5"></i><b>(5)</b>
    {
      std::cout &lt;&lt; "Bad command line argument" &lt;&lt; std::endl;
      return 5;
    },

    [](leaf::error_info const &amp; unmatched) <i class="conum" data-value="6"></i><b>(6)</b>
    {
      std::cerr &lt;&lt;
        "Unknown failure detected" &lt;&lt; std::endl &lt;&lt;
        "Cryptic diagnostic information follows" &lt;&lt; std::endl &lt;&lt;
        unmatched;
      return 6;
    }
  );
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>This handler will be called if the detected error includes:<br>
• an object of type <code>enum error_code</code> equal to the value <code>input_file_open_error</code>, and<br>
• an object of type <code>leaf::e_errno</code> that has <code>.value</code> equal to <code>ENOENT</code>, and<br>
• an object of type <code>leaf::e_file_name</code>.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>This handler will be called if the detected error includes:<br>
• an object of type <code>enum error_code</code> equal to <code>input_file_open_error</code>, and<br>
• an object of type <code>leaf::e_errno</code> (regardless of its <code>.value</code>), and<br>
• an object of type <code>leaf::e_file_name</code>.</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>This handler will be called if the detected error includes:<br>
• an object of type <code>enum error_code</code> equal to any of <code>input_file_size_error</code>, <code>input_file_read_error</code>, <code>input_eof_error</code>, and<br>
• an object of type <code>leaf::e_errno</code> (regardless of its <code>.value</code>), and<br>
• an object of type <code>leaf::e_file_name</code>.</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i><b>4</b></td>
<td>This handler will be called if the detected error includes:<br>
• an object of type <code>enum error_code</code> equal to <code>cout_error</code>, and<br>
• an object of type <code>leaf::e_errno</code> (regardless of its <code>.value</code>),</td>
</tr>
<tr>
<td><i class="conum" data-value="5"></i><b>5</b></td>
<td>This handler will be called if the detected error includes an object of type <code>enum error_code</code> equal to <code>bad_command_line</code>.</td>
</tr>
<tr>
<td><i class="conum" data-value="6"></i><b>6</b></td>
<td>This last handler is a catch-all for any error, in case no other handler could be matched: it prints diagnostic information to help debug logic errors in the program, since it failed to match an appropriate error handler to the error condition it encountered.</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Now, reading and printing a file may not seem like a complex job, but let&#8217;s split it into several functions, each communicating failures using <code>leaf::result&lt;T&gt;</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight nowrap"><code class="language-c++" data-lang="c++">//Parse the command line, return the file name.
leaf::result&lt;char const *&gt; parse_command_line( int argc, char const * argv[] );

//Open a file for reading.
leaf::result&lt;std::shared_ptr&lt;FILE&gt;&gt; file_open( char const * file_name );

//Return the size of the file.
leaf::result&lt;int&gt; file_size( FILE &amp; f );

//Read size bytes from f into buf.
leaf::result&lt;void&gt; file_read( FILE &amp; f, void * buf, int size );</code></pre>
</div>
</div>
<div class="paragraph">
<p>For example, let&#8217;s look at <code>file_open</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight nowrap"><code class="language-c++" data-lang="c++">leaf::result&lt;std::shared_ptr&lt;FILE&gt;&gt; file_open( char const * file_name )
{
  if( FILE * f = fopen(file_name,"rb") )
    return std::shared_ptr&lt;FILE&gt;(f,&amp;fclose);
  else
    return leaf::new_error( input_file_open_error, leaf::e_errno{errno} );
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>If <code>fopen</code> succeeds, we return a <code>shared_ptr</code> which will automatically call <code>fclose</code> as needed. If <code>fopen</code> fails, we report an error by calling <code>new_error</code>, which takes any number of error objects to load with the error. In this case we pass the system <code>errno</code> (LEAF defines <code>struct e_errno {int value;}</code>), and our own error code value, <code>input_file_open_error</code>.</p>
</div>
<div class="paragraph">
<p>Here is our complete error code <code>enum</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight nowrap"><code class="language-c++" data-lang="c++">enum error_code
{
  bad_command_line = 1,
  input_file_open_error,
  input_file_size_error,
  input_file_read_error,
  input_eof_error,
  cout_error
};</code></pre>
</div>
</div>
<div class="paragraph">
<p>Looks good, but how does LEAF know that this <code>enum</code> represents error codes and not, say, types of cold cuts sold at Bay Cities Italian Deli? It doesn&#8217;t, unless we tell it:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight nowrap"><code class="language-c++" data-lang="c++">namespace boost { namespace leaf {

  template&lt;&gt; struct is_e_type&lt;error_code&gt;: std::true_type { };

} }</code></pre>
</div>
</div>
<div class="paragraph">
<p>We&#8217;re now ready to look at the <code>TryBlock</code> we&#8217;ll pass to <code>try_handle_all</code>. It does all the work, bails out if it encounters an error:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight nowrap"><code class="language-c++" data-lang="c++">int main( int argc, char const * argv[] )
{
  return leaf::try_handle_all(

    [&amp;]() -&gt; leaf::result&lt;int&gt;
    {
      leaf::result&lt;char const *&gt; file_name = parse_command_line(argc,argv);
      if( !file_name )
        return file_name.error();</code></pre>
</div>
</div>
<div class="paragraph">
<p>Wait, what&#8217;s this, if "error" return "error"? There is a better way: we&#8217;ll use <code>LEAF_AUTO</code>. It takes a <code>result&lt;T&gt;</code> and bails out in case of a failure (control leaves the calling function), otherwise defines a local variable to access the <code>T</code> value stored in the <code>result</code> object.</p>
</div>
<div class="paragraph">
<p>This is what our <code>TryBlock</code> really looks like:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight nowrap"><code class="language-c++" data-lang="c++">int main( int argc, char const * argv[] )
{
  return leaf::try_handle_all(

    [&amp;]() -&gt; leaf::result&lt;int&gt; <i class="conum" data-value="1"></i><b>(1)</b>
    {
      LEAF_AUTO(file_name, parse_command_line(argc,argv)); <i class="conum" data-value="2"></i><b>(2)</b>

      auto load = leaf::preload( leaf::e_file_name{file_name} ); <i class="conum" data-value="3"></i><b>(3)</b>

      LEAF_AUTO(f, file_open(file_name)); <i class="conum" data-value="4"></i><b>(4)</b>

      LEAF_AUTO(s, file_size(*f)); <i class="conum" data-value="4"></i><b>(4)</b>

      std::string buffer( 1 + s, '\0' );
      LEAF_CHECK(file_read(*f, &amp;buffer[0], buffer.size()-1)); <i class="conum" data-value="4"></i><b>(4)</b>

      std::cout &lt;&lt; buffer;
      std::cout.flush();
      if( std::cout.fail() ) <i class="conum" data-value="5"></i><b>(5)</b>
        return leaf::new_error( cout_error, leaf::e_errno{errno} );

      return 0;
    },

    .... // The list of error handlers goes here

  ); <i class="conum" data-value="6"></i><b>(6)</b>
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Our <code>TryBlock</code> returns a <code>result&lt;int&gt;</code>. In case of success, it will hold <code>0</code>, which will be returned from <code>main</code> to the OS.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>If <code>parse_command_line</code> returns an error, we forward that error to <code>try_handle_all</code> (which invoked us) verbatim. Otherwise, <code>LEAF_AUTO</code> gets us a local variable <code>file_name</code> to access the <code>char const *</code> result.</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>From now on, all errors escaping this scope will automatically communicate the (now successfully parsed from the command line) file name (LEAF defines <code>struct e_file_name {std::string value;}</code>). It&#8217;s as if every time one of the following functions wants to report an error, <code>preload</code> says "wait, associate this <code>e_file_name</code> object with the error, it&#8217;s important!"</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i><b>4</b></td>
<td>Call more functions, forward each failure to the caller&#8230;&#8203;</td>
</tr>
<tr>
<td><i class="conum" data-value="5"></i><b>5</b></td>
<td>&#8230;&#8203;but this is slightly different: we didn&#8217;t get a failure via <code>result&lt;T&gt;</code> from another function, this is our own error we&#8217;ve detected! We return a <code>new_error</code>, passing the <code>cout_error</code> error code and the system <code>errno</code> (LEAF defines <code>struct e_errno {int value;}</code>).</td>
</tr>
<tr>
<td><i class="conum" data-value="6"></i><b>6</b></td>
<td>This concludes the <code>try_handle_all</code> arguments&#8201;&#8212;&#8201;as well as our program!</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Nice and simple! Writing the <code>TryBlock</code>, we focus on the "no errors" code path&#8201;&#8212;&#8201;if we encounter any error we just return it to <code>try_handle_all</code> for processing. Well, that&#8217;s if we&#8217;re being good and using RAII for automatic clean-up&#8201;&#8212;&#8201;which we are, <code>shared_ptr</code> will automatically close the file for us.</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
The complete program from this tutorial is available <a href="https://github.com/zajo/leaf/blob/master/examples/print_file_result.cpp?ts=4">here</a>. The <a href="https://github.com/zajo/leaf/blob/master/examples/print_file_eh.cpp?ts=4">other</a> version of the same program uses exception handling to report errors (see <a href="#introduction-eh">below</a>).
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect2">
<h3 id="introduction-eh">Using Exception Handling</h3>
<div class="paragraph">
<p>And now, we&#8217;ll write the same program that reads a text file in a buffer and prints it to <code>std::cout</code>, this time using exceptions to report errors. First, we need to define our exception class hierarchy:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight nowrap"><code class="language-c++" data-lang="c++">struct print_file_error : virtual std::exception { };
struct command_line_error : virtual print_file_error { };
struct bad_command_line : virtual command_line_error { };
struct input_error : virtual print_file_error { };
struct input_file_error : virtual input_error { };
struct input_file_open_error : virtual input_file_error { };
struct input_file_size_error : virtual input_file_error { };
struct input_file_read_error : virtual input_file_error { };
struct input_eof_error : virtual input_file_error { };</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
To avoid ambiguities in the dynamic type conversion which occur when catching a base type, it is generally recommended to use virtual inheritance in exception type hierarchies.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Again, we&#8217;ll split the job into several functions, this time communicating failures by throwing exceptions (and, therefore, we do not need to use a <code>result&lt;T&gt;</code> type):</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight nowrap"><code class="language-c++" data-lang="c++">//Parse the command line, return the file name.
char const * parse_command_line( int argc, char const * argv[] );

//Open a file for reading.
std::shared_ptr&lt;FILE&gt; file_open( char const * file_name );

//Return the size of the file.
int file_size( FILE &amp; f );

//Read size bytes from f into buf.
void file_read( FILE &amp; f, void * buf, int size );</code></pre>
</div>
</div>
<div class="paragraph">
<p>The <code>main</code> function brings everything together and handles all the exceptions that are thrown, but instead of using <code>try</code> and <code>catch</code>, it will use the function template <code>leaf::try_catch</code>, which has the following signature:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight nowrap"><code class="language-c++" data-lang="c++">template &lt;class TryBlock, class... Handler&gt;
&lt;&lt;deduced-type&gt;&gt; try_catch( TryBlock &amp;&amp; try_block, Handler &amp;&amp; ... handler );</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>TryBlock</code> is a function type, almost always a lambda; <code>try_catch</code> simply returns the value returned by the <code>try_block</code>, catching any exception it throws, in which case it calls the first suitable error handling function from the <code>handler&#8230;&#8203;</code> list.</p>
</div>
<div class="paragraph">
<p>Let&#8217;s look at the <code>TryBlock</code> our <code>main</code> function passes to <code>try_catch</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight nowrap"><code class="language-c++" data-lang="c++">int main( int argc, char const * argv[] )
{
  std::cout.exceptions(std::ostream::failbit | std::ostream::badbit); <i class="conum" data-value="1"></i><b>(1)</b>

  return leaf::try_catch(

    [&amp;] <i class="conum" data-value="2"></i><b>(2)</b>
    {
      char const * file_name = parse_command_line(argc,argv); <i class="conum" data-value="3"></i><b>(3)</b>

      auto load = leaf::preload( leaf::e_file_name{file_name} ); <i class="conum" data-value="4"></i><b>(4)</b>

      std::shared_ptr&lt;FILE&gt; f = file_open( file_name ); <i class="conum" data-value="3"></i><b>(3)</b>

      std::string buffer( 1+file_size(*f), '\0' ); <i class="conum" data-value="3"></i><b>(3)</b>
      file_read(*f,&amp;buffer[0],buffer.size()-1); <i class="conum" data-value="3"></i><b>(3)</b>

      auto propagate2 = leaf::defer([] { return leaf::e_errno{errno}; } ); <i class="conum" data-value="5"></i><b>(5)</b>
      std::cout &lt;&lt; buffer;
      std::cout.flush();

      return 0;
    },

    .... <i class="conum" data-value="6"></i><b>(6)</b>

  ); <i class="conum" data-value="7"></i><b>(7)</b>
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Configure <code>std::cout</code> to throw on error.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>Except if it throws, our <code>TryBlock</code> returns <code>0</code>, which will be returned from <code>main</code> to the OS.</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>If any of the functions we call throws, <code>try_catch</code> will find an appropriate handler to invoke. We&#8217;ll look at that later.</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i><b>4</b></td>
<td>From now on, all exceptions escaping this scope will automatically communicate the (now successfully parsed from the command line) file name (LEAF defines <code>struct e_file_name {std::string value;}</code>). It&#8217;s as if every time one of the following functions wants to throw an exception, <code>preload</code> says "wait, associate this <code>e_file_name</code> object with the exception, it&#8217;s important!"</td>
</tr>
<tr>
<td><i class="conum" data-value="5"></i><b>5</b></td>
<td><code>defer</code> is similar to <code>preload</code>, but instead of the error object, it takes a function that returns it. From this point on, if an exception escapes this scope, <code>defer</code> will call the passed function and load the returned <code>e_errno</code> with the exception (LEAF defines <code>struct e_errno {int value;}</code>).</td>
</tr>
<tr>
<td><i class="conum" data-value="6"></i><b>6</b></td>
<td>List of error handlers goes here. We&#8217;ll see that later.</td>
</tr>
<tr>
<td><i class="conum" data-value="7"></i><b>7</b></td>
<td>This concludes the <code>try_catch</code> arguments&#8201;&#8212;&#8201;as well as our program!</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>As it is always the case when using exception handling, as long as our <code>TryBlock</code> is exception-safe, we can focus on the "no errors" code path. Of course, our <code>TryBlock</code> is exception-safe, since <code>shared_ptr</code> will automatically close the file for us in case an exception is thrown.</p>
</div>
<div class="paragraph">
<p>Now let&#8217;s look at the second part of the call to <code>try_catch</code>, which lists the error handlers:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight nowrap"><code class="language-c++" data-lang="c++">int main( int argc, char const * argv[] )
{
  std::cout.exceptions(std::ostream::failbit | std::ostream::badbit); <i class="conum" data-value="1"></i><b>(1)</b>

  return leaf::try_catch(
    [&amp;]
    {
      .... <i class="conum" data-value="2"></i><b>(2)</b>
    },

    [](leaf::catch_&lt;input_file_open_error&gt;, <i class="conum" data-value="3"></i><b>(3)</b>
        leaf::match&lt;leaf::e_errno,ENOENT&gt;,
        leaf::e_file_name const &amp; fn)
    {
      std::cerr &lt;&lt; "File not found: " &lt;&lt; fn.value &lt;&lt; std::endl;
      return 1;
    },

    [](leaf::catch_&lt;input_file_open_error&gt;, <i class="conum" data-value="4"></i><b>(4)</b>
        leaf::e_errno const &amp; errn,
        leaf::e_file_name const &amp; fn )
    {
      std::cerr &lt;&lt; "Failed to open " &lt;&lt; fn.value &lt;&lt; ", errno=" &lt;&lt; errn &lt;&lt; std::endl;
      return 2;
    },

    [](leaf::catch_&lt;input_error&gt;, <i class="conum" data-value="5"></i><b>(5)</b>
        leaf::e_errno const &amp; errn,
        leaf::e_file_name const &amp; fn )
    {
      std::cerr &lt;&lt; "Failed to access " &lt;&lt; fn.value &lt;&lt; ", errno=" &lt;&lt; errn &lt;&lt; std::endl;
      return 3;
    },

    [](leaf::catch_&lt;std::ostream::failure&gt;, <i class="conum" data-value="6"></i><b>(6)</b>
        leaf::e_errno const &amp; errn )
    {
      std::cerr &lt;&lt; "Output error, errno=" &lt;&lt; errn &lt;&lt; std::endl;
      return 4;
    },

    [](leaf::catch_&lt;bad_command_line&gt;) <i class="conum" data-value="7"></i><b>(7)</b>
    {
      std::cout &lt;&lt; "Bad command line argument" &lt;&lt; std::endl;
      return 5;
    },

    [](leaf::error_info const &amp; unmatched) <i class="conum" data-value="8"></i><b>(8)</b>
    {
      std::cerr &lt;&lt;
        "Unknown failure detected" &lt;&lt; std::endl &lt;&lt;
        "Cryptic diagnostic information follows" &lt;&lt; std::endl &lt;&lt;
        unmatched;
      return 6;
    } );
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Configure <code>std::cout</code> to throw on error.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>This is the <code>TryBlock</code> from the previous listing; if it throws, <code>try_catch</code> will catch the exception, then consider the error handlers that follow, in order, and it will call the first one that can deal with the error:</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>This handler will be called if:<br>
• an <code>input_file_open_error</code> exception was caught, with<br>
• an object of type <code>leaf::e_errno</code> that has <code>.value</code> equal to <code>ENOENT</code>, and<br>
• an object of type <code>leaf::e_file_name</code>.</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i><b>4</b></td>
<td>This handler will be called if:<br>
• an <code>input_file_open_error</code> exception was caught, with<br>
• an object of type <code>leaf::e_errno</code> (regardless of its <code>.value</code>), and<br>
• an object of type <code>leaf::e_file_name</code>.</td>
</tr>
<tr>
<td><i class="conum" data-value="5"></i><b>5</b></td>
<td>This handler will be called if:<br>
• an <code>input_error</code> exception was caught (which is a base type), with<br>
• an object of type <code>leaf::e_errno</code> (regardless of its <code>.value</code>), and<br>
• an object of type <code>leaf::e_file_name</code>.</td>
</tr>
<tr>
<td><i class="conum" data-value="6"></i><b>6</b></td>
<td>This handler will be called if:<br>
• an <code>std::ostream::failure</code> exception was caught, with<br>
• an object of type <code>leaf::e_errno</code> (regardless of its <code>.value</code>),</td>
</tr>
<tr>
<td><i class="conum" data-value="7"></i><b>7</b></td>
<td>This handler will be called if a <code>bad_command_line</code> exception was caught.</td>
</tr>
<tr>
<td><i class="conum" data-value="8"></i><b>8</b></td>
<td>If <code>try_catch</code> fails to find an appropriate handler, it will re-throw the exception. But this is the <code>main</code> function which should handle all exceptions, so this last handler matches any error and prints diagnostic information, to help debug logic errors.</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>To conclude this introduction, let&#8217;s look at one of the error-reporting functions that our <code>TryBlock</code> calls, for example <code>file_open</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight nowrap"><code class="language-c++" data-lang="c++">std::shared_ptr&lt;FILE&gt; file_open( char const * file_name )
{
  if( FILE * f = fopen(file_name,"rb") )
    return std::shared_ptr&lt;FILE&gt;(f,&amp;fclose);
  else
    throw leaf::exception( input_file_open_error(), leaf::e_errno{errno} );
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>If <code>fopen</code> succeeds, it returns a <code>shared_ptr</code> which will automatically call <code>fclose</code> as needed. If <code>fopen</code> fails, we throw the exception object returned by <code>leaf::exception</code>, which takes as its first argument an exception object, followed by any number of error objects to load with it. In this case we pass the system <code>errno</code> (LEAF defines <code>struct e_errno {int value;}</code>). The returned object can be caught as <code>input_file_open_error</code>.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<code>try_catch</code> works with any exception, not only exceptions thrown using <code>leaf::exception</code>.
</td>
</tr>
</table>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
The complete program from this tutorial is available <a href="https://github.com/zajo/leaf/blob/master/examples/print_file_eh.cpp?ts=4">here</a>. The <a href="https://github.com/zajo/leaf/blob/master/examples/print_file_result.cpp?ts=4">other</a> version of the same program does not use exception handling to report errors (see the <a href="#introduction-result">previous introduction</a>).
</td>
</tr>
</table>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="tutorial">Tutorial</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="tutorial-definitions">Definitions</h3>
<div class="paragraph">
<p>The following terms are used throughout this documentation:</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">Error types, or E-types: </dt>
<dd>
<p>User-defined value types that describe or pertain to a failure. Objects of these types may carry <code>std::error_code</code>, error enums, relevant file names, and any other information that is required by an error-handling scope in case of a failure. E-types must define no-throw move, but need not be copyable.</p>
</dd>
<dt class="hdlist1">error_id: </dt>
<dd>
<p>This is a value type that acts as a program-wide unique identifier of a particular occurrence of a failure. It is as efficient as an <code>int</code>. In addition the <code>error_id</code> type is implicitly convertible to <code>std::error_code</code>. This enables LEAF error IDs to be communicated through any compatible API in plain <code>std::error_code</code> objects, which LEAF recognizes by its own specific <code>std::error_category</code>.</p>
</dd>
<dt class="hdlist1">context&lt;E&#8230;&#8203;&gt;: </dt>
<dd>
<p>A <code>context</code> is an associative container of E-types, which it stores statically in a <code>std::tuple</code>. A <code>context</code> object may store at most a single object of each of the <code>E&#8230;&#8203;</code> types. When an E-object is stored in a <code>context</code>, it is always associated with a specific <code>error_id</code> value. Typically, <code>context</code> objects are local to the <code>try_handle_some</code>, <code>try_handle_all</code> or <code>try_catch</code> function invoked by an error-handling scope.</p>
</dd>
<dt class="hdlist1">Error-initiating function: </dt>
<dd>
<p>A function that detects and reports a new failure. Usually such functions call <code>new_error</code> to generate a new <code>error_id</code> for each error condition they encounter; typically, at least one E-object is associated with the new <code>error_id</code> at this point.</p>
</dd>
<dt class="hdlist1">Error-neutral function: </dt>
<dd>
<p>A function which, in case a lower level function fails, forwards the reported error to its caller, possibly associating additional E-objects with it.</p>
</dd>
<dt class="hdlist1">Error-handling function: </dt>
<dd>
<p>A function that recognizes and recovers from at least some errors reported by lower level functions. Error-handling functions typically call <code>try_handle_some</code>, <code>try_handle_all</code> or <code>try_catch</code>, passing a list of handlers.</p>
</dd>
<dt class="hdlist1">Handler: </dt>
<dd>
<p>A function (almost always a lambda), which is able to handle a specific error condition identified by its arguments (usually of E-types). In typical use, if a low-level function attempts to communicate an E-object, it is discarded unless at least one error-handling scope up the call chain contains a handler that takes an argument of that E-type.</p>
<div class="paragraph">
<p>Scopes that handle errors require an <code>error_id</code> and a list of handlers, which they typically pass to <code>try_handle_some</code>, <code>try_handle_all</code> or <code>try_catch</code>. The <code>error_id</code> is transported in one of the following ways:</p>
</div>
<div class="openblock">
<div class="content">
<div class="ulist">
<ul>
<li>
<p>in a <a href="#result"><code>leaf::result&lt;T&gt;</code></a> object,</p>
</li>
<li>
<p>in a <code>std::error_code</code> object, or</p>
</li>
<li>
<p>in an exception object returned by <a href="#exception"><code>leaf::exception</code></a>.</p>
</li>
</ul>
</div>
</div>
</div>
<div class="paragraph">
<p>To handle an error, LEAF calls the first of the specified handlers whose arguments can be supplied by the E-objects loaded in a local <code>context</code> that are associated with the delivered <code>error_id</code>.</p>
</div>
</dd>
</dl>
</div>
<hr>
</div>
<div class="sect2">
<h3 id="tutorial-model">Error Communication Model</h3>
<div class="sect3">
<h4 id="_using_noexcept_functionality">Using <code>noexcept</code> Functionality</h4>
<div class="paragraph">
<p>The following figure illustrates how error objects are transported when using LEAF without exception handling:</p>
</div>
<div class="imageblock">
<div class="content">
<img src="LEAF-1.png" alt="LEAF 1">
</div>
<div class="title">Figure 1. LEAF noexcept Error Communication Model</div>
</div>
<div class="paragraph">
<p>The arrows pointing down indicate the call stack order for the functions <code>f1</code> through <code>f5</code>: higher level functions calling lower level functions.</p>
</div>
<div class="paragraph">
<p>Note the call to <code>preload</code> in <code>f3</code>: it caches the passed E-objects of types <code>E1</code> and <code>E3</code> in the returned object <code>load</code>, where they stay ready to be communicated in case any function downstream from <code>f3</code> reports an error. Presumably these objects are relevant to any such failure, but are conveniently accessible only in this scope.</p>
</div>
<div class="paragraph">
<p><em>Figure 1</em> depicts the condition where <code>f5</code> has detected an error. It calls <code>leaf::new_error</code> to create a new, unique <code>error_id</code>. The passed E-object of type <code>E2</code> is immediately loaded in the first active <code>context</code> object that provides static storage for it, found in any calling scope (in this case <code>f1</code>), and is associated with the newly-generated <code>error_id</code> (solid arrow);</p>
</div>
<div class="paragraph">
<p>The <code>error_id</code> itself is returned to the immediate caller <code>f4</code>, usually stored in a <code>result&lt;T&gt;</code> object <code>r</code>. That object takes the path shown by dashed arrows, as each error-neutral function, unable to handle the failure, forwards it to its immediate caller in the returned value&#8201;&#8212;&#8201;until an error-handling scope is reached.</p>
</div>
<div class="paragraph">
<p>When the destructor of the <code>load</code> object in <code>f3</code> executes, it detects that <code>new_error</code> was invoked after its initialization, loads the cached objects of types <code>E1</code> and <code>E3</code> in the first active <code>context</code> object that provides static storage for them, found in any calling scope (in this case <code>f1</code>), and associates them with the last generated <code>error_id</code> (solid arrow).</p>
</div>
<div class="paragraph">
<p>When the error-handling scope <code>f1</code> is reached, it probes <code>ctx</code> for any E-objects associated with the <code>error_id</code> it received from <code>f2</code>, and processes a list of user-provided error handlers (almost always lambda functions), in order, until it finds a handler with arguments that match the available E-objects. That handler is called to deal with the failure.</p>
</div>
</div>
<div class="sect3">
<h4 id="_using_exception_handling">Using Exception Handling</h4>
<div class="paragraph">
<p>The following figure illustrates the slightly different error communication model used when errors are reported by throwing exceptions:</p>
</div>
<div class="imageblock">
<div class="content">
<img src="LEAF-2.png" alt="LEAF 2">
</div>
<div class="title">Figure 2. LEAF Error Communication Model Using Exception Handling</div>
</div>
<div class="paragraph">
<p>The main difference is that the call to <code>new_error</code> is implicit in the call to the function template <code>leaf::exception</code>, which takes an exception object (in this case of type <code>Ex</code>), and returns an exception object of unspecified type that derives publicly from <code>Ex</code> and from <code>error_id</code>.</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
In addition to the <code>error_id</code> being transported in the returned exception object, it is possible for error-neutral scopes to <code>catch(error_id const &amp;)</code> if they need to intercept any LEAF-specific exception.
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="tutorial-interoperability">Interoperability</h4>
<div class="paragraph">
<p>Ideally, when an error is detected, a program using LEAF would always call <a href="#new_error"><code>new_error</code></a>, ensuring that each encountered error is definitely assigned a unique <a href="#error_id"><code>error_id</code></a>, which then is reliably delivered, by an exception or by a <code>result&lt;T&gt;</code> object, to the appropriate error-handling scope.</p>
</div>
<div class="paragraph">
<p>Alas, this is not always possible.</p>
</div>
<div class="paragraph">
<p>For example, the error may need to be communicated through uncooperative 3rd-party interfaces. To facilitate this transmission, a error ID may be encoded in a <code>std::error_code</code>. As long as a 3rd-party interface understands <code>std::error_code</code>, it should be compatible with LEAF.</p>
</div>
<div class="paragraph">
<p>Further, it is sometimes necessary to communicate errors through an interface that does not even use <code>std::error_code</code>. An example of this is when an external lower-level library throws an exception, which is unlikely to be able to carry an <code>error_id</code>.</p>
</div>
<div class="paragraph">
<p>To support this tricky use case, LEAF provides the function <a href="#current_error"><code>current_error</code></a>, which returns the error ID returned by the most recent call (from this thrad) to <a href="#new_error"><code>new_error</code></a>. One possible approach is to use the following logic (implemented by <a href="#augment_id"><code>augment_id</code></a>):</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Before calling the (possibly uncooperative) API, call <a href="#current_error"><code>current_error</code></a> and store the returned value.</p>
</li>
<li>
<p>Call the API, then call <code>current_error</code> again:</p>
<div class="olist loweralpha">
<ol class="loweralpha" type="a">
<li>
<p>If this returns the same value as before, pass the error objects to <code>new_error</code> to associate them with a new <code>error_id</code>;</p>
</li>
<li>
<p>else, associate the error objects with the <code>error_id</code> value returned by the second call to <code>current_error</code>.</p>
</li>
</ol>
</div>
</li>
</ol>
</div>
<div class="paragraph">
<p>Note that if the above logic is nested (e.g. one function calling another), <code>new_error</code> will be called only by the inner-most function, because that call guarantees that all calling functions will hit the <code>else</code> branch.</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
To avoid ambiguities, whenever possible, use the <a href="#exception"><code>exception</code></a> function template when throwing exceptions to ensure that the exception object transports a unique <code>error_id</code>; better yet, use the <a href="#LEAF_THROW"><code>LEAF_THROW</code></a> macro, which in addition will capture <code>__FILE__</code> and <code>__LINE__</code>.
</td>
</tr>
</table>
</div>
<hr>
</div>
</div>
<div class="sect2">
<h3 id="tutorial-is_e_type">E-types</h3>
<div class="paragraph">
<p>With LEAF, users can efficiently associate with errors or with exceptions any number of values that pertain to a failure. These values may be of any no-throw movable type <code>E</code> for which <code><a href="#is_e_type">is_e_type</a>&lt;E&gt;::value</code> is <code>true</code>. The expectation is that this template will be specialized as needed for e.g. all user-defined error code enums.</p>
</div>
<div class="paragraph">
<p>Formally, types <code>E</code> for which <code>is_e_type&lt;E&gt;::value</code> is <code>true</code> are called E-types. Objects of those types are called error objects or E-objects.</p>
</div>
<div class="paragraph">
<p>The main <code>is_e_type</code> template is defined so that <code>is_e_type&lt;E&gt;::value</code> is <code>true</code> when <code>E</code> is:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>any type which defines an accessible data member <code>value</code>.</p>
</li>
<li>
<p>any type <code>E</code> for which <code>std::is_base_of&lt;std::exception, E&gt;::value</code> is <code>true</code>,</p>
</li>
<li>
<p><code>std::exception_ptr</code>,</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Often, error values that need to be communicated are of generic types (e.g. <code>std::string</code>). Such values should be enclosed in a C-<code>struct</code> that acts as their compile-time identifier and gives them semantic meaning. Examples:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight nowrap"><code class="language-c++" data-lang="c++">struct e_input_name  { std::string value; };
struct e_output_name { std::string value; };

struct e_minimum_temperature { float value; };
struct e_maximum_temperature { float value; };</code></pre>
</div>
</div>
<div class="paragraph">
<p>By convention, the enclosing C-<code>struct</code> names use the <code>e_</code> prefix.</p>
</div>
<hr>
</div>
<div class="sect2">
<h3 id="tutorial-context_deduction">Automatic Deduction of <code>context</code> Types</h3>
<div class="paragraph">
<p>In LEAF, E-objects are always stored in <code><a href="#context">context</a>&lt;E&#8230;&#8203;&gt;</code> objects, typically created in the local scope of an error handling function.</p>
</div>
<div class="paragraph">
<p>While it is possible to instantiate the <code>context</code> class template directly with a list of E-types, this is prone to errors. Consider that attempts to communicate an E-object of a type for which no active <code>context</code> provides storage lead to that object being discarded; therefore, it is critical that any E-type required by a handler in order to deal with a given failure participates in the instantiation of the <code>context</code> template.</p>
</div>
<div class="paragraph">
<p>The possibility of this mismatch can be eliminated by automatically deducing the <code>E&#8230;&#8203;</code> types used to instantiate the <code>context</code> template from the list of handlers that actually recognize and recover from various error conditions. This, in fact, is how <a href="#try_handle_all"><code>try_handle_all</code></a>, <a href="#try_handle_some"><code>try_handle_some</code></a> and <a href="#try_catch"><code>try_catch</code></a> work. For example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight nowrap"><code class="language-c++" data-lang="c++">leaf::try_handle_all(

  [&amp;]
  {
    // Operations which may fail <i class="conum" data-value="1"></i><b>(1)</b>
  },

  []( my_error_enum x ) <i class="conum" data-value="2"></i><b>(2)</b>
  {
    ...
  },

  []( read_file_error_enum y, e_file_name const &amp; fn ) <i class="conum" data-value="3"></i><b>(3)</b>
  {
    ...
  },

  []
  {
    ...
  });</code></pre>
</div>
</div>
<div class="paragraph text-right">
<p><a href="#try_handle_all"><code>try_handle_all</code></a></p>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>The <code>try_handle_all</code> scope that invoked this lambda contains a local object of automatically deduced type <code>context&lt;my_error_enum, read_file_error_enum, e_file_name&gt;</code>. Reported E-objects of any other type are discarded, because they are not needed in order to recover from errors.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>Reported E-objects of type <code>my_error_enum</code> will be loaded in the <code>context</code> (rather than discarded), because they are needed by this handler.</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>Reported E-objects of type <code>read_file_error_enum</code> or <code>e_file_name</code> will be loaded in the <code>context</code> (rather than discarded), because they are needed by this handler.</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect2">
<h3 id="tutorial-loading">Loading</h3>
<div class="paragraph">
<p>When an E-object is loaded, it is immediately moved into an active <a href="#context"><code>context</code></a> object, usually local to a <a href="#try_handle_some"><code>try_handle_some</code></a>, a <a href="#try_handle_all"><code>try_handle_all</code></a> or a <a href="#try_catch"><code>try_catch</code></a> scope in the calling thread, where it becomes uniquely associated with a specific <a href="#error_id"><code>error_id</code></a>&#8201;&#8212;&#8201;or discarded if storage is not available.</p>
</div>
<div class="paragraph">
<p>Various LEAF functions take a list of E-objects to load. As an example, if a function <code>copy_file</code> that takes the name of the input file and the name of the output file as its arguments detects a failure, it could communicate an error code <code>ec</code>, plus the two relevant file names using <a href="#new_error"><code>new_error</code></a>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight nowrap"><code class="language-c++" data-lang="c++">return leaf::new_error( ec, e_input_name{n1}, e_output_name{n2} );</code></pre>
</div>
</div>
<div class="paragraph">
<p>Alternatively, E-objects may be loaded using a <code>result&lt;T&gt;</code> that is already communicating an error. This way they become associated with that error, rather than with a new error:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight nowrap"><code class="language-c++" data-lang="c++">leaf::result&lt;int&gt; f();

leaf::result&lt;void&gt; g( char const * fn )
{
  if( leaf::result&lt;int&gt; fr = f() )
  {
    // Use *fr, then...
    return { }; // ...indicate success.
  }
  else
  {
    // f() failed, associate an additional e_file_name with the failure.
    return fr.load( e_file_name{fn} );
  }
}</code></pre>
</div>
</div>
<div class="paragraph text-right">
<p><a href="#result"><code>result</code></a> | <a href="#result::load"><code>load</code></a></p>
</div>
<hr>
</div>
<div class="sect2">
<h3 id="tutorial-accumulation">Accumulation</h3>
<div class="paragraph">
<p>"Accumulating" an E-object is similar to "<a href="#tutorial-loading">loading</a>" it, but where loading takes an E-object, moves it to an active <a href="#context"><code>context</code></a> and associates it with a particular <a href="#error_id"><code>error_id</code></a>, accumulation takes a function and calls it with the E-object currently stored in the <code>context</code>, associated with the <code>error_id</code>. If no such E-object is available, a new one is default-initialized and then passed to the function.</p>
</div>
<div class="paragraph">
<p>For example, if an operation that involves many different files fails, a program may provide for collecting all relevant file names in a <code>e_relevant_file_names</code> object:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight nowrap"><code class="language-c++" data-lang="c++">struct e_relevant_file_names
{
  std::vector&lt;std::string&gt; value;
};

leaf::result&lt;void&gt; operation( char const * file_name )
{
  if( leaf::result&lt;int&gt; r = try_something() )
  {
    ....
    return { }; <i class="conum" data-value="1"></i><b>(1)</b>
  }
  else
  {
    return r.accumulate( <i class="conum" data-value="2"></i><b>(2)</b>
      [&amp;]( e_relevant_file_names &amp; e )
      {
        e.value.push_back(file_name);
      } );
  }
}</code></pre>
</div>
</div>
<div class="paragraph text-right">
<p><a href="#result"><code>result</code></a> | <a href="#result::accumulate"><code>accumulate</code></a></p>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Indicate success to the caller.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td><code>try_something</code> failed&#8201;&#8212;&#8201;add <code>file_name</code> to the <code>e_relevant_file_names</code> object, associated with the <code>error_id</code> communicated in <code>r</code>.</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>As is always the case with LEAF, the accumulation (or loading) only takes place if a handler passed to <a href="#try_handle_some"><code>try_handle_some</code></a>, <a href="#try_handle_all"><code>try_handle_all</code></a> or <a href="#try_catch"><code>try_catch</code></a> takes an argument of type <code>e_relevant_file_names</code>; otherwise the active <code>context</code> would not provide storage for this type and the corresponding accumulation code would not be executed.</p>
</div>
<div class="paragraph">
<p>In other words, the accumulation of <code>e_relevant_file_names</code> will only occur if an error-handling caller function actually needs that information.</p>
</div>
<hr>
</div>
<div class="sect2">
<h3 id="tutorial-preload">Using <code>preload</code></h3>
<div class="paragraph">
<p>It is not typical for an error-initiating function to be able to supply all of the data needed by the error-handling function in order to recover from the failure. For example, a function that reports a <code>FILE</code> operation failure may not have access to the file name, yet an error handling function needs it in order to print a useful error message.</p>
</div>
<div class="paragraph">
<p>Of course the file name is typically readily available in the call stack leading to the failed <code>FILE</code> operation. In the example below, while <code>parse_info</code> can&#8217;t report the file name, <code>parse_file</code> can and does:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight nowrap"><code class="language-c++" data-lang="c++">leaf::result&lt;info&gt; parse_info( FILE * f ) noexcept; <i class="conum" data-value="1"></i><b>(1)</b>

leaf::result&lt;info&gt; parse_file( char const * file_name ) noexcept
{
  auto load = leaf::preload( leaf::e_file_name{file_name} ); <i class="conum" data-value="2"></i><b>(2)</b>

  if( FILE * f = fopen(file_name,"r") )
  {
    auto r = parse_info(f);
    fclose(f);
    return r;
  }
  else
    return leaf::new_error( error_enum::file_open_error );
}</code></pre>
</div>
</div>
<div class="paragraph text-right">
<p><a href="#result"><code>result</code></a> | <a href="#preload"><code>preload</code></a> | <a href="#new_error"><code>new_error</code></a></p>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td><code>parse_info</code> parses <code>f</code>, communicating errors using <code>result&lt;info&gt;</code>.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>Using <code>preload</code> ensures that the file name is included with any error reported out of <code>parse_file</code>. All we need to do is hold on to the returned object <code>load</code>: when it expires, if an error is being reported, the passed <code>e_file_name</code> value will be automatically associated with it.</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>For <code>preload</code> to work, it must succeed in associating the passed E-objects with the correct <code>error_id</code>. The algorithm used to achieve this is as follows:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>If the calling thread has invoked <a href="#new_error"><code>new_error</code></a> since the call to <code>preload</code>, the E-objects are associated with the <a href="#error_id"><code>error_id</code></a> returned by <a href="#current_error"><code>current_error</code></a>. This association effectively targets the <code>error_id</code> value carried in the most recently created <code>result&lt;T&gt;</code> object <strong>or</strong> the exception object most recently returned by <a href="#exception"><code>leaf::exception</code></a>.</p>
</li>
<li>
<p>Else, if <code>std::uncaught_exception()</code> is <code>true</code>, the E-objects are associated with the <code>error_id</code> returned by <a href="#new_error"><code>new_error</code></a>. This association targets exception objects that were not created using <code>leaf::exception</code> and therefore do not carry an <code>error_id</code> (see <a href="#tutorial-interoperability">Interoperability</a>).</p>
</li>
</ul>
</div>
<hr>
</div>
<div class="sect2">
<h3 id="tutorial-defer">Capturing <code>errno</code> with <code>defer</code></h3>
<div class="paragraph">
<p>Consider the following function:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight nowrap"><code class="language-c++" data-lang="c++">void read_file(FILE * f) {
  ....
  size_t nr=fread(buf,1,count,f);
  if( ferror(f) )
    throw leaf::exception( file_read_error(), e_errno{errno} );
  ....
}</code></pre>
</div>
</div>
<div class="paragraph text-right">
<p><code><a href="#exception">exception</a></code> | <a href="#e_errno"><code>e_errno</code></a></p>
</div>
<div class="paragraph">
<p>It is pretty straight-forward, reporting <code>e_errno</code> as it detects a <code>ferror</code>. But what if it calls <code>fread</code> multiple times?</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight nowrap"><code class="language-c++" data-lang="c++">void read_file(FILE * f) {
  ....
  size_t nr1=fread(buf1,1,count1,f);
  if( ferror(f) )
    throw leaf::exception( file_read_error(), e_errno{errno} );

  size_t nr2=fread(buf2,1,count2,f);
  if( ferror(f) )
    throw leaf::exception( file_read_error(), e_errno{errno} );

  size_t nr3=fread(buf3,1,count3,f);
  if( ferror(f) )
    throw leaf::exception( file_read_error(), e_errno{errno} );
  ....
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Ideally, associating <code>e_errno</code> with each exception should be automated. One way to achieve this is to not call <code>fread</code> directly, but wrap it in another function which checks for <code>ferror</code> and associates the <code>e_errno</code> with the exception it throws.</p>
</div>
<div class="paragraph">
<p><a href="#tutorial-preload">Using <code>preload</code></a> we can  solve a very similar problem without a wrapper function, but that technique does not work for <code>e_errno</code> because <code><a href="#preload">preload</a></code> would capture <code>errno</code> before a <code>fread</code> call was attempted, at which point <code>errno</code> is probably <code>0</code>&#8201;&#8212;&#8201;or, worse, leftover from a previous I/O failure.</p>
</div>
<div class="paragraph">
<p>The solution is to use <code><a href="#defer">defer</a></code>, so we don&#8217;t have to remember to include <code>e_errno</code> with each exception; <code>errno</code> will be associated automatically with any exception that escapes <code>read_file</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight nowrap"><code class="language-c++" data-lang="c++">void read_file(FILE * f) {

  auto load = leaf::defer([]{ return e_errno{errno}; });

  ....
  size_t nr1=fread(buf1,1,count1,f);
  if( ferror(f) )
    throw leaf::exception(file_read_error());

  size_t nr2=fread(buf2,1,count2,f);
  if( ferror(f) )
    throw leaf::exception(file_read_error());

  size_t nr3=fread(buf3,1,count3,f);
  if( ferror(f) )
    throw leaf::exception(file_read_error());
  ....
}</code></pre>
</div>
</div>
<div class="paragraph text-right">
<p><a href="#defer"><code>defer</code></a> | <code><a href="#exception">exception</a></code> | <a href="#e_errno"><code>e_errno</code></a></p>
</div>
<div class="paragraph">
<p>This works similarly to <code>preload</code>, except that the capturing of the <code>errno</code> is deferred until the destructor of the <code>load</code> object is called, which calls the passed lambda function to obtain the <code>errno</code>.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
This technique works exactly the same way when errors are reported using <code>leaf::<a href="#result">result</a></code> rather than by throwing exceptions.
</td>
</tr>
</table>
</div>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<i class="fa icon-warning" title="Warning"></i>
</td>
<td class="content">
Keep in mind that the function passed to <code>defer</code>, if invoked, is being executed in the destructor of the <code>load</code> object; make sure it does not throw exceptions.
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect2">
<h3 id="tutorial-accumulate">Deferred <code>accumulate</code></h3>
<div class="paragraph">
<p>Let&#8217;s say we want to build a record of file locations a given error passes through on its way to be handled. We couldn&#8217;t do it with <code>preload</code>, because in this case we need to accumulate information, rather than store it.</p>
</div>
<div class="paragraph">
<p>One option would be to call the <a href="#error_id"><code>error_id</code></a> member function <a href="#error_id::accumulate"><code>accumulate</code></a> or the <a href="#result"><code>result</code></a> member function <a href="#result::accumulate"><code>accumulate</code></a>, but these are more convenient when we have a specific error object in our hands, rather than when we just want the information accumulated no matter what the error is.</p>
</div>
<div class="paragraph">
<p>Usually, the best option is to use <a href="#accumulate"><code>accumulate</code></a>, which works similarly to <a href="#preload"><code>preload</code></a>, but it uses the familiar accumulate interface instead:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight nowrap"><code class="language-c++" data-lang="c++">struct e_trace
{
  struct rec
  {
    char const * file;
    int line;
  };
  std::deque&lt;rec&gt; value;
};

leaf::result&lt;int&gt; f1();
leaf::result&lt;int&gt; f2();

leaf::result&lt;int&gt; sum()
{
  auto acc = leaf::accumulate( []( e_trace &amp; x ) <i class="conum" data-value="1"></i><b>(1)</b>
  {
    x.push_back(e_trace::rec{__FILE__, __LINE__});
  } );

  LEAF_AUTO(a, f1()); <i class="conum" data-value="2"></i><b>(2)</b>
  LEAF_AUTO(b, f2()); <i class="conum" data-value="3"></i><b>(3)</b>
  return a + b; <i class="conum" data-value="4"></i><b>(4)</b>
}</code></pre>
</div>
</div>
<div class="paragraph text-right">
<p><a href="#result"><code>result</code></a> | <a href="#accumulate"><code>accumulate</code></a> | <a href="#LEAF_AUTO"><code>LEAF_AUTO</code></a></p>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>This lambda will be called in case an error is communicated by either <code>f1</code> or <code>f2</code> (below), but only if the error handling scope needs an <code>e_trace</code>.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>Call <code>f1</code>, return error or get a value in <code>a</code>.</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>Call <code>f2</code>, return error or get a value in <code>b</code>.</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i><b>4</b></td>
<td>Compute result.</td>
</tr>
</table>
</div>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<i class="fa icon-warning" title="Warning"></i>
</td>
<td class="content">
Keep in mind that the function passed to <code>accumulate</code>, if invoked, is being executed in the destructor of the <code>acc</code> object; make sure it does not throw exceptions.
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect2">
<h3 id="tutorial-remote_handlers">Working with Remote Handlers</h3>
<div class="paragraph">
<p>Consider this snippet:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight nowrap"><code class="language-c++" data-lang="c++">leaf::try_handle_all(

  [&amp;]
  {
    // Operations which may fail
  },

  []( my_error_enum x )
  {
    ...
  },

  []( read_file_error_enum y, e_file_name const &amp; fn )
  {
    ...
  },

  []
  {
    ...
  });</code></pre>
</div>
</div>
<div class="paragraph text-right">
<p><a href="#try_handle_all"><code>try_handle_all</code></a> | <a href="#e_file_name"><code>e_file_name</code></a></p>
</div>
<div class="paragraph">
<p>Looks pretty simple and clean, but what if we need to attempt a different set of operations yet use the same handlers? We could repeat the same thing with a different lambda passed as <code>TryBlock</code> for <code>try_handle_all</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight nowrap"><code class="language-c++" data-lang="c++">leaf::try_handle_all(

  [&amp;]
  {
    // Different operations which may fail
  },

  []( my_error_enum x )
  {
    ...
  },

  []( read_file_error_enum y, e_file_name const &amp; fn )
  {
    ...
  },

  []
  {
    ...
  });</code></pre>
</div>
</div>
<div class="paragraph">
<p>That works, but LEAF also allows error handlers to be captured and reused. This API is actually very easy to use if a bit unintuitive. This is how a set of handlers can be captured:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight nowrap"><code class="language-c++" data-lang="c++">auto handle_error = []( leaf::error_info const &amp; error )
{
  return leaf::remote_handle_all( error, <i class="conum" data-value="1"></i><b>(1)</b>

    []( my_error_enum x )
    {
      ...
    },

    []( read_file_error_enum y, e_file_name const &amp; fn )
    {
      ...
    },

    []
    {
      ...
    });
};</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>The helper function <code>remote_handle_all</code>, as well as its alternatives <code>remote_handle_some</code> and <code>remote_handle_exception</code> have no purpose other than to enable capturing of remote handlers; do not call them in any other case.</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>The tricky bit is to keep in mind that the call to the helper function <code>leaf::remote_handle_all</code> does not occur at this time; all that happens is that its gnarly return type is captured by <code>auto</code>, enabling LEAF to later "know" what kind handlers the <code>handle_error</code> function invokes.</p>
</div>
<div class="paragraph">
<p>With this in place, reusing these so-called remote handlers is a simple matter of calling <code>remote_try_handle_all</code> instead of <code>try_handle_all</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight nowrap"><code class="language-c++" data-lang="c++">leaf::remote_try_handle_all(
  [&amp;]
  {
    // Operations which may fail <i class="conum" data-value="1"></i><b>(1)</b>
  },
  [&amp;]( leaf::error_info const &amp; error )
  {
    return handle_error(error); <i class="conum" data-value="3"></i><b>(3)</b>
  } );

leaf::remote_try_handle_all(
  [&amp;]
  {
    // Different operations which may fail <i class="conum" data-value="2"></i><b>(2)</b>
  },
  [&amp;]( leaf::error_info const &amp; error )
  {
    return handle_error(error); <i class="conum" data-value="3"></i><b>(3)</b>
  } );</code></pre>
</div>
</div>
<div class="paragraph text-right">
<p><a href="#remote_try_handle_all"><code>remote_try_handle_all</code></a> | <a href="#error_info"><code>error_info</code></a></p>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>One set of operations which may fail&#8230;&#8203;</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>A different set of operations which may fail&#8230;&#8203;</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>&#8230;&#8203; both using the same <code>handle_error</code> capture we created earlier.</td>
</tr>
</table>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
The captured lambda function must take at least one argument of type <code>leaf::error_info const &amp;</code>, because LEAF invokes the error handling lambda function we pass to <a href="#remote_try_handle_all"><code>remote_try_handle_all</code></a> with a <code>leaf::error_info</code>. Note however that LEAF does not call <code>handle_error</code> directly, which means that it can take any additional arguments it needs in order to deal with failures, as long as they can be supplied when it is invoked.
</td>
</tr>
</table>
</div>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<i class="fa icon-warning" title="Warning"></i>
</td>
<td class="content">
LEAF provides three sets of "remote handler" APIs, "handle_all" (as presented above), "handle_some" and "handle_exception", and it is critical that they are not mixed up. Since in this example the <code>handle_error</code> lambda calls the helper function <code>remote_handle_all</code>, it can only be used in a call to <a href="#remote_try_handle_all"><code>remote_try_handle_all</code></a>. If we needed a capture that can be used with e.g. <a href="#remote_try_catch"><code>remote_try_catch</code></a>, it must be calling the <code>remote_handle_exception</code> helper function instead.
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect2">
<h3 id="tutorial-async">Transporting Error Objects Between Threads</h3>
<div class="paragraph">
<p><code>E-objects</code> use automatic storage duration, stored in an instance of the <a href="#context"><code>context</code></a> template in the scope of e.g. <a href="#try_handle_some"><code>try_handle_some</code></a>, <a href="#try_handle_all"><code>try_handle_all</code></a> or <a href="#try_catch"><code>try_catch</code></a> functions. When using concurrency, we need a mechanism to collect E-objects in one thread, then use them to handle errors in another thread.</p>
</div>
<div class="paragraph">
<p>LEAF offers two interfaces for this purpose, one using <code>result&lt;T&gt;</code>, and another designed for programs that use exception handling.</p>
</div>
<div class="sect3">
<h4 id="tutorial-async_result">Using <code>result&lt;T&gt;</code></h4>
<div class="paragraph">
<p>Let&#8217;s assume we have a <code>task</code> that we want to launch asynchronously, which produces a <code>task_result</code> but could also fail:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight nowrap"><code class="language-c++" data-lang="c++">leaf::result&lt;task_result&gt; task();</code></pre>
</div>
</div>
<div class="paragraph">
<p>Because the task will run asynchronously, in case of a failure we need it to capture the relevant E-objects but not handle errors. To this end, in the main thread we first create a remote handler which we will later use to handle errors from each completed asynchronous task (see <a href="#tutorial-remote_handlers">Working with Remote Handlers</a>):</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight nowrap"><code class="language-c++" data-lang="c++">auto handle_error = []( leaf::error_info const &amp; error )
{
  return leaf::remote_handle_some( error,

    []( E1 e1, E2 e2 )
    {
      //Deal with E1, E2
      ....
      return { };
    },

    []( E3 e3 )
    {
      //Deal with E3
      ....
      return { };
    } );
};</code></pre>
</div>
</div>
<div class="paragraph">
<p>Why did we start with this step? Because we need to create a <a href="#context"><code>context</code></a> object to collect the E-objects we need. We <em>could</em> just instantiate the <code>context</code> template with <code>E1</code>, <code>E2</code> and <code>E3</code>, but that would be prone to errors, since it could get out of sync with the handlers we use. Thankfully LEAF can deduce the types we need automatically from the remote handler we created. To create our <code>context</code> object, we just call <a href="#make_shared_context"><code>make_shared_context</code></a>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight nowrap"><code class="language-c++" data-lang="c++">std::shared_ptr&lt;leaf::polymorphic_context&gt; ctx = leaf::make_shared_context(&amp;handle_error);</code></pre>
</div>
</div>
<div class="paragraph">
<p>The <code>polymorphic_context</code> type is an abstract base class that has the same members as any instance of the <code>context</code> class template, allowing us to erase its exact type. So in this case what we&#8217;re holding in <code>ctx</code> is a <code>context&lt;E1, E2, E3&gt;</code>, which were deduced automatically from the type of the <code>handle_error</code> object we passed to <code>make_shared_context</code>.</p>
</div>
<div class="paragraph">
<p>We&#8217;re now ready to launch our asynchronous task:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight nowrap"><code class="language-c++" data-lang="c++">std::future&lt;leaf::result&lt;task_result&gt;&gt; launch_task()
{
  return std::async(
    std::launch::async,
    [&amp;]
    {
      std::shared_ptr&lt;leaf::polymorphic_context&gt; ctx = leaf::make_shared_context(&amp;handle_error);
      return leaf::capture(ctx, &amp;task);
    } );
}</code></pre>
</div>
</div>
<div class="paragraph text-right">
<p><a href="#result"><code>result</code></a> | <a href="#make_shared_context"><code>make_shared_context</code></a> | <a href="#capture"><code>capture</code></a></p>
</div>
<div class="paragraph">
<p>That&#8217;s it! Later when we <code>get</code> the <code>std::future</code>, we can process the returned <code>result&lt;task_result&gt;</code> in a call to <a href="#remote_try_handle_some"><code>remote_try_handle_some</code></a>, using the <code>handle_error</code> remote handler we created earlier, as if it was generated locally:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight nowrap"><code class="language-c++" data-lang="c++">//std::future&lt;leaf::result&lt;task_result&gt;&gt; fut;
fut.wait();

return leaf::remote_try_handle_some(

  [&amp;]() -&gt; leaf::result&lt;void&gt;
  {
    LEAF_AUTO(r, fut.get());
    //Success!
    return { }
  },

  [&amp;]( leaf::error_info const &amp; error )
  {
    return handle_error(error); // Invoke the remote handler we captured earlier.
  } );</code></pre>
</div>
</div>
<div class="paragraph text-right">
<p><a href="#remote_try_handle_some"><code>remote_try_handle_some</code></a> | <a href="#result"><code>result</code></a> | <a href="#LEAF_AUTO"><code>LEAF_AUTO</code></a> | <a href="#error_info"><code>error_info</code></a></p>
</div>
<div class="paragraph">
<p>The reason this works is that in case it communicates a failure, <code>leaf::result&lt;T&gt;</code> is able to hold a <code>shared_ptr&lt;polymorphic_context&gt;</code> object. That is why earlier instead of calling <code>task()</code> directly, we called <code>leaf::capture</code>: it calls the passed function, and in case it fails it stores the <code>shared_ptr&lt;polymorphic_context&gt;</code> we created in the returned <code>result&lt;T&gt;</code>, which now doesn&#8217;t just communicate the fact that an error has occurred, but also holds the <code>context</code> object that <code>remote_try_handle_some</code> needs in order to find a matching handler.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
Follow this link to see a complete example program: <a href="https://github.com/zajo/leaf/blob/master/examples/capture_in_result.cpp?ts=4">capture_in_result.cpp</a>.
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="tutorial-async_eh">Using Exception Handling</h4>
<div class="paragraph">
<p>Let&#8217;s assume we have a <code>task</code> which produces a <code>task_result</code> but could also throw:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight nowrap"><code class="language-c++" data-lang="c++">task_result task();</code></pre>
</div>
</div>
<div class="paragraph">
<p>Just like we saw in <a href="#tutorial-async_result">Using <code>result&lt;T&gt;</code></a>, first we will create a remote handler:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight nowrap"><code class="language-c++" data-lang="c++">auto handle_error = []( leaf::error_info const &amp; error )
{
  return leaf::remote_handle_exception( error,

    []( E1 e1, E2 e2 )
    {
      //Deal with E1, E2
      ....
      return { };
    },

    []( E3 e3 )
    {
      //Deal with E3
      ....
      return { };
    } );
};</code></pre>
</div>
</div>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<i class="fa icon-warning" title="Warning"></i>
</td>
<td class="content">
The handler looks almost the same as the one we created in <a href="#tutorial-async_result">Using <code>result&lt;T&gt;</code></a>, but note the difference that here we call the helper function <code>remote_handle_exception</code> rather than <code>remote_handle_some</code>. This is important, because we will later use <code>handle_error</code> with <code>remote_try_catch</code>, not with <code>remote_try_handle_some</code>.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Launching the task looks the same as before, except that we don&#8217;t use <code>result&lt;T&gt;</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight nowrap"><code class="language-c++" data-lang="c++">std::future&lt;task_result&gt; launch_task()
{
  return std::async(
    std::launch::async,
    [&amp;]
    {
      std::shared_ptr&lt;leaf::polymorphic_context&gt; ctx = leaf::make_shared_context(&amp;handle_error);
      return leaf::capture(ctx, &amp;task);
    } );
}</code></pre>
</div>
</div>
<div class="paragraph text-right">
<p><a href="#make_shared_context"><code>make_shared_context</code></a> | <a href="#capture"><code>capture</code></a></p>
</div>
<div class="paragraph">
<p>That&#8217;s it! Later when we <code>get</code> the <code>std::future</code>, we can process the returned <code>task_result</code> in a call to <a href="#remote_try_catch"><code>remote_try_catch</code></a>, using the <code>handle_error</code> remote handler we created earlier, as if it was generated locally:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight nowrap"><code class="language-c++" data-lang="c++">//std::future&lt;task_result&gt; fut;
fut.wait();

return leaf::remote_try_catch(

  [&amp;]
  {
    task_result r = fut.get(); // Throws on error
    //Success!
  },

  [&amp;]( leaf::error_info const &amp; error )
  {
    return handle_error(error); // Invoke the remote handler we captured earlier.
  } );</code></pre>
</div>
</div>
<div class="paragraph text-right">
<p><a href="#remote_try_catch"><code>remote_try_catch</code></a> | <a href="#error_info"><code>error_info</code></a></p>
</div>
<div class="paragraph">
<p>This works similarly to using <code>result&lt;T&gt;</code>, except that the <code>std::shared_ptr&lt;polymorphic_context&gt;</code> is transported in an exception object (of unspecified type which <a href="#remote_try_catch"><code>remote_try_catch</code></a> recognizes and then automatically unwraps the original exception).</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
Follow this link to see a complete example program: <a href="https://github.com/zajo/leaf/blob/master/examples/capture_in_exception.cpp?ts=4">capture_in_exception.cpp</a>.
</td>
</tr>
</table>
</div>
<hr>
</div>
</div>
<div class="sect2">
<h3 id="tutorial-disparate_error_types">Working with Disparate Error Types</h3>
<div class="paragraph">
<p>Because most libraries define their own mechanism for reporting errors, programmers often need to use multiple incompatible error-initiating interfaces in the same program. This led to the introduction of <code>boost::system::error_code</code> which later became <code>std::error_code</code>. Each <code>std::error_code</code> object is assigned an <code>error_category</code>. Libraries that communicate errors in terms of <code>std::error_code</code> define their own <code>error_category</code>. For libraries that do not, the user can "easily" define a custom <code>error_category</code> and still translate domain-specific error codes to <code>std::error_code</code>.</p>
</div>
<div class="paragraph">
<p>But let&#8217;s take a step back and consider <em>why</em> did we want to express every error in terms of the same static type, <code>std::error_code</code> in the first place? We need this translation because the C&#43;&#43; static type-checking system makes it difficult to write functions that may return error objects of the disparate static types used by different libraries. Outside of this limitation, it would be preferable to be able to write functions that can communicate errors in terms of arbitrary C&#43;&#43; types, as needed.</p>
</div>
<div class="paragraph">
<p>To drive this point further, consider the real world problem of mixing <code>boost::system::error_code</code> and <code>std::error_code</code> in the same program. In theory, both systems are designed to be able to express one error code in terms of the other. In practice, describing a <em>generic</em> system for error categorization in terms of another <em>generic</em> system for error categorization may not be trivial.</p>
</div>
<div class="paragraph">
<p>Ideally, functions should be able to communicate different error types without having to translate between them. Using LEAF, a scope that is able to handle either <code>std::error_code</code> or <code>boost::system::error_code</code> would look like this:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight nowrap"><code class="language-c++" data-lang="c++">return try_handle_some(

  []() -&gt; leaf::result&lt;T&gt; <i class="conum" data-value="1"></i><b>(1)</b>
  {
    // Call operations which may report std::error_code and boost::system::error_code.
  },

  []( std::error_code const &amp; e )
  {
    .... <i class="conum" data-value="2"></i><b>(2)</b>
  },

  []( boost::system::error_code const &amp; e )
  {
    .... <i class="conum" data-value="3"></i><b>(3)</b>
  } );</code></pre>
</div>
</div>
<div class="paragraph text-right">
<p><a href="#try_handle_some"><code>try_handle_some</code></a> |  <a href="#result"><code>result</code></a></p>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Communicate errors via <code>result&lt;T&gt;</code>.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>Handle <code>std::error_code</code> errors.</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>Handle <code>boost::system::error_code</code> errors.</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>And here is a function which, using LEAF, forwards either <code>std::error_code</code> or <code>boost::system::error_code</code> objects reported by lower level functions:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight nowrap"><code class="language-c++" data-lang="c++">leaf::result&lt;void&gt; f()
{
  if( std::error_code ec = g1() )
    return leaf::new_error(ec);

  if( boost::system::error_code ec = g2() )
    return leaf::new_error(ec);

  return {};
}</code></pre>
</div>
</div>
<div class="paragraph text-right">
<p><a href="#result"><code>result</code></a> | <a href="#new_error"><code>new_error</code></a></p>
</div>
<hr>
</div>
<div class="sect2">
<h3 id="tutorial-exception_to_result">Converting Exceptions to <code>result&lt;T&gt;</code></h3>
<div class="paragraph">
<p>It is sometimes necessary to catch exceptions thrown by a lower-level library function, and report the error through different means, to a higher-level library which may not use exception handling.</p>
</div>
<div class="paragraph">
<p>Suppose we have an exception type hierarchy and a function <code>compute_answer_throws</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight nowrap"><code class="language-c++" data-lang="c++">class error_base: public virtual std::exception { };
class error_a: public virtual error_base { };
class error_b: public virtual error_base { };
class error_c: public virtual error_base { };

int compute_answer_throws()
{
  switch( rand()%4 )
  {
    default: return 42;
    case 1: throw error_a();
    case 2: throw error_b();
    case 3: throw error_c();
  }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>We can write a simple wrapper using <code>exception_to_result</code>, which calls <code>compute_answer_throws</code> and switches to <code>result&lt;int&gt;</code> for error handling:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight nowrap"><code class="language-c++" data-lang="c++">leaf::result&lt;int&gt; compute_answer() noexcept
{
  return leaf::exception_to_result&lt;error_a, error_b&gt;(
    []
    {
      return compute_answer_throws();
    } );
}</code></pre>
</div>
</div>
<div class="paragraph text-right">
<p><a href="#result"><code>result</code></a> | <a href="#exception_to_result"><code>exception_to_result</code></a></p>
</div>
<div class="paragraph">
<p>(As a demonstration, <code>compute_answer</code> specifically converts exceptions of type <code>error_a</code> or <code>error_b</code>, while it leaves <code>error_c</code> to be captured by <code>std::exception_ptr</code>).</p>
</div>
<div class="paragraph">
<p>Here is a simple function which prints successfully computed answers, forwarding any error (originally reported by throwing an exception) to its caller:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight nowrap"><code class="language-c++" data-lang="c++">leaf::result&lt;void&gt; print_answer() noexcept
{
  LEAF_AUTO(answer, compute_answer());
  std::cout &lt;&lt; "Answer: " &lt;&lt; answer &lt;&lt; std::endl;
  return { };
}</code></pre>
</div>
</div>
<div class="paragraph text-right">
<p><a href="#result"><code>result</code></a> | <a href="#LEAF_AUTO"><code>LEAF_AUTO</code></a></p>
</div>
<div class="paragraph">
<p>Finally, here is a scope that handles the errors (which used to be exception objects):</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight nowrap"><code class="language-c++" data-lang="c++">leaf::try_handle_all(

  []() -&gt; leaf::result&lt;void&gt;
  {
    LEAF_CHECK(print_answer());
    return { };
  },

  []( error_a const &amp; e )
  {
    std::cerr &lt;&lt; "Error A!" &lt;&lt; std::endl;
  },

  []( error_b const &amp; e )
  {
    std::cerr &lt;&lt; "Error B!" &lt;&lt; std::endl;
  },

  []
  {
    std::cerr &lt;&lt; "Unknown error!" &lt;&lt; std::endl;
  } );</code></pre>
</div>
</div>
<div class="paragraph text-right">
<p><a href="#try_handle_all"><code>try_handle_all</code></a> | <a href="#result"><code>result</code></a> | <a href="#LEAF_CHECK"><code>LEAF_CHECK</code></a></p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
The complete program illustrating this technique is available <a href="https://github.com/zajo/leaf/blob/master/examples/exception_to_result.cpp?ts=4">here</a>.
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect2">
<h3 id="tutorial-preload_in_c_callbacks">Using <code>augment_id</code> in (Lua) C-callbacks</h3>
<div class="paragraph">
<p>Communicating information pertaining to a failure detected in a C callback is tricky, because C callbacks are limited to a specific static signature, which may not use C&#43;&#43; types.</p>
</div>
<div class="paragraph">
<p>LEAF makes this easy. As an example, we&#8217;ll write a program that uses Lua and reports a failure from a C&#43;&#43; function registered as a C callback, called from a Lua program. The failure will be propagated from C&#43;&#43;, through the Lua interpreter (written in C), back to the C&#43;&#43; function which called it.</p>
</div>
<div class="paragraph">
<p>C/C&#43;&#43; functions designed to be invoked from a Lua program must use the following signature:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight nowrap"><code class="language-c" data-lang="c">int do_work( lua_State * L ) ;</code></pre>
</div>
</div>
<div class="paragraph">
<p>Arguments are passed on the Lua stack (which is accessible through <code>L</code>). Results too are pushed onto the Lua stack.</p>
</div>
<div class="paragraph">
<p>First, let&#8217;s initialize the Lua interpreter and register <code>do_work</code> as a C callback, available for Lua programs to call:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight nowrap"><code class="language-c++" data-lang="c++">std::shared_ptr&lt;lua_State&gt; init_lua_state() noexcept
{
  std::shared_ptr&lt;lua_State&gt; L(lua_open(),&amp;lua_close); <i class="conum" data-value="1"></i><b>(1)</b>

  lua_register( &amp;*L, "do_work", &amp;do_work ); <i class="conum" data-value="2"></i><b>(2)</b>

  luaL_dostring( &amp;*L, "\ <i class="conum" data-value="3"></i><b>(3)</b>
\n      function call_do_work()\
\n          return do_work()\
\n      end" );

  return L;
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Create a new <code>lua_State</code>. We&#8217;ll use <code>std::shared_ptr</code> for automatic cleanup.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>Register the <code>do_work</code> C&#43;&#43; function as a C callback, under the global name <code>"do_work"</code>. With this, calls from Lua programs to <code>do_work</code> will land in the <code>do_work</code> C&#43;&#43; function.</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>Pass some Lua code as a <code>C</code> string literal to Lua. This creates a global Lua function called <code>call_do_work</code>, which we will later ask Lua to execute.</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Next, let&#8217;s define our <code>enum</code> used to communicate <code>do_work</code> failures:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight nowrap"><code class="language-c++" data-lang="c++">enum do_work_error_code
{
  ec1=1,
  ec2
};

namespace boost { namespace leaf {

  template&lt;&gt; struct is_e_type&lt;do_work_error_code&gt;: std::true_type { };

} }</code></pre>
</div>
</div>
<div class="paragraph text-right">
<p><a href="#is_e_type"><code>is_e_type</code></a></p>
</div>
<div class="paragraph">
<p>We&#8217;re now ready to define the <code>do_work</code> callback function:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight nowrap"><code class="language-c++" data-lang="c++">int do_work( lua_State * L ) noexcept
{
  bool success=rand()%2; <i class="conum" data-value="1"></i><b>(1)</b>
  if( success )
  {
    lua_pushnumber(L,42); <i class="conum" data-value="2"></i><b>(2)</b>
    return 1;
  }
  else
  {
    leaf::new_error(ec1); <i class="conum" data-value="3"></i><b>(3)</b>
    return luaL_error(L,"do_work_error"); <i class="conum" data-value="4"></i><b>(4)</b>
  }
}</code></pre>
</div>
</div>
<div class="paragraph text-right">
<p><a href="#new_error"><code>new_error</code></a> | <a href="#error_id::load"><code>load</code></a></p>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>"Sometimes" <code>do_work</code> fails.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>In case of success, push the result on the Lua stack, return back to Lua.</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>Generate a new <code>error_id</code> and associate a <code>do_work_error_code</code> with it. Normally, we&#8217;d return this in a <code>leaf::result&lt;T&gt;</code>, but the <code>do_work</code> function signature (required by Lua) does not permit this.</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i><b>4</b></td>
<td>Tell the Lua interpreter to abort the Lua program.</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Now we&#8217;ll write the function that calls the Lua interpreter to execute the Lua function <code>call_do_work</code>, which in turn calls <code>do_work</code>. We&#8217;ll return <code><a href="#result">result</a>&lt;int&gt;</code>, so that our caller can get the answer in case of success, or an error:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight nowrap"><code class="language-c++" data-lang="c++">leaf::result&lt;int&gt; call_lua( lua_State * L )
{
  lua_getfield( L, LUA_GLOBALSINDEX, "call_do_work" );
  augment_id augment;
  if( int err=lua_pcall(L,0,1,0) ) <i class="conum" data-value="1"></i><b>(1)</b>
  {
    auto load = leaf::preload( e_lua_error_message{lua_tostring(L,1)} ); <i class="conum" data-value="2"></i><b>(2)</b>
    lua_pop(L,1);
    return aughent.get_error( e_lua_pcall_error{err} ); <i class="conum" data-value="3"></i><b>(3)</b>
  }
  else
  {
    int answer=lua_tonumber(L,-1); <i class="conum" data-value="4"></i><b>(4)</b>
    lua_pop(L,1);
    return answer;
  }
}</code></pre>
</div>
</div>
<div class="paragraph text-right">
<p><a href="#result"><code>result</code></a> | <a href="#preload"><code>preload</code></a> | <a href="#augment_id"><code>augment_id</code></a></p>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Ask the Lua interpreter to call the global Lua function <code>call_do_work</code>.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td><code>preload</code> works as usual.</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td><code>get_error</code> will return the <code>error_id</code> generated in our Lua callback. This is the same <code>error_id</code> the <code>preload</code> uses as well.</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i><b>4</b></td>
<td>Success! Just return the <code>int</code> answer.</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Finally, here is the <code>main</code> function which exercises <code>call_lua</code>, each time handling any failure:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight nowrap"><code class="language-c++" data-lang="c++">int main() noexcept
{
  std::shared_ptr&lt;lua_State&gt; L=init_lua_state();

  for( int i=0; i!=10; ++i )
  {
    leaf::try_handle_all(

      [&amp;]() -&gt; leaf::result&lt;void&gt;
      {
        LEAF_AUTO(answer, call_lua(&amp;*L));
        std::cout &lt;&lt; "do_work succeeded, answer=" &lt;&lt; answer &lt;&lt; '\n'; <i class="conum" data-value="1"></i><b>(1)</b>
        return { };
      },

      []( do_work_error_code e ) <i class="conum" data-value="2"></i><b>(2)</b>
      {
        std::cout &lt;&lt; "Got do_work_error_code = " &lt;&lt; e &lt;&lt;  "!\n";
      },

      []( e_lua_pcall_error const &amp; err, e_lua_error_message const &amp; msg ) <i class="conum" data-value="3"></i><b>(3)</b>
      {
        std::cout &lt;&lt; "Got e_lua_pcall_error, Lua error code = " &lt;&lt; err.value &lt;&lt; ", " &lt;&lt; msg.value &lt;&lt; "\n";
      },

      []( leaf::error_info const &amp; unmatched )
      {
        std::cerr &lt;&lt;
          "Unknown failure detected" &lt;&lt; std::endl &lt;&lt;
          "Cryptic diagnostic information follows" &lt;&lt; std::endl &lt;&lt;
          unmatched;
      } );
  }</code></pre>
</div>
</div>
<div class="paragraph text-right">
<p><a href="#try_handle_all"><code>try_handle_all</code></a> | <a href="#result"><code>result</code></a> | <a href="#LEAF_AUTO"><code>LEAF_AUTO</code></a> | <a href="#error_info"><code>error_info</code></a></p>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>If the call to <code>call_lua</code> succeeded, just print the answer.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>Handle <code>do_work</code> failures.</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>Handle all other <code>lua_pcall</code> failures.</td>
</tr>
</table>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>Follow this link to see the complete program: <a href="https://github.com/zajo/leaf/blob/master/examples/lua_callback_result.cpp?ts=4">lua_callback_result.cpp</a>.</p>
</div>
<div class="paragraph">
<p>Remarkably, the Lua interpreter is C&#43;&#43; exception-safe, even though it is written in C. Here is the same program, this time using a C&#43;&#43; exception to report failures from <code>do_work</code>: <a href="https://github.com/zajo/leaf/blob/master/examples/lua_callback_eh.cpp?ts=4">lua_callback_eh.cpp</a>.</p>
</div>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect2">
<h3 id="tutorial-diagnostic_information">Diagnostic Information</h3>
<div class="paragraph">
<p>LEAF is able to automatically generate diagnostic messages that include information about all E-objects available to error handlers. For this purpose, it needs to be able to print objects of user-defined E-types.</p>
</div>
<div class="paragraph">
<p>To do this, LEAF attempts to bind an unqualified call to <code>operator&lt;&lt;</code>, passing a <code>std::ostream</code> and the E-object. If that fails, it will also attempt to bind <code>operator&lt;&lt;</code> that takes the <code>.value</code> of the E-object. If that also doesn&#8217;t compile, the E-object value will not appear in diagnostic messages, though LEAF will still print its type.</p>
</div>
<div class="paragraph">
<p>Even with E-types that define a printable <code>.value</code>, the user may still want to overload <code>operator&lt;&lt;</code> for the enclosing <code>struct</code>, e.g.:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight nowrap"><code class="language-c++" data-lang="c++">struct e_errno
{
  int value;

  friend std::ostream &amp; operator&lt;&lt;( std::ostream &amp; os, e_errno const &amp; e )
  {
    return os &lt;&lt; "errno = " &lt;&lt; e.value &lt;&lt; ", \"" &lt;&lt; strerror(e.value) &lt;&lt; '"';
  }
};</code></pre>
</div>
</div>
<div class="paragraph">
<p>The <code>e_errno</code> type above is designed to hold <code>errno</code> values. The defined <code>operator&lt;&lt;</code> overload will automatically include the output from <code>strerror</code> when <code>e_errno</code> values are printed (LEAF defines <code>e_errno</code> in <code>&lt;boost/leaf/common.hpp&gt;</code>, together with other commonly-used error types).</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
These automatically-generated diagnostic messages are developer-friendly, but not user-friendly. Therefore, <code>operator&lt;&lt;</code> overloads for E-types should only print technical information in English, and should not attempt to localize strings or to format a user-friendly message; this should be done in error-handling functions specifically designed for that purpose.
</td>
</tr>
</table>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="examples">Examples</h2>
<div class="sectionbody">
<div class="ulist">
<ul>
<li>
<p><a href="https://github.com/zajo/leaf/blob/master/examples/print_file_result.cpp?ts=4">print_file_result.cpp</a>: The complete example from the Five Minute Introduction <a href="#introduction-result">Using <code>result&lt;T&gt;</code></a>.</p>
</li>
<li>
<p><a href="https://github.com/zajo/leaf/blob/master/examples/print_file_outcome_result.cpp?ts=4">print_file_outcome_result.cpp</a>: The complete example from the Five Minute Introduction, but using Boost <code>outcome::result&lt;T&gt;</code> instead of <code>leaf::<a href="#result">result&lt;T</a>&gt;</code>.</p>
</li>
<li>
<p><a href="https://github.com/zajo/leaf/blob/master/examples/print_file_eh.cpp?ts=4">print_file_eh.cpp</a>: The complete example from the Five Minute Introduction <a href="#introduction-eh">Using Exception Handling</a>.</p>
</li>
<li>
<p><a href="https://github.com/zajo/leaf/blob/master/examples/capture_in_result.cpp?ts=4">capture_in_result.cpp</a>: Shows how to transport E-objects between threads in a <code><a href="#result">result</a>&lt;T&gt;</code> object.</p>
</li>
<li>
<p><a href="https://github.com/zajo/leaf/blob/master/examples/capture_in_exception.cpp?ts=4">capture_in_exception.cpp</a>: Shows how to transport E-objects between threads in an exception object.</p>
</li>
<li>
<p><a href="https://github.com/zajo/leaf/blob/master/examples/lua_callback_result.cpp?ts=4">lua_callback_result.cpp</a>: Transporting arbitrary E-objects through an uncooperative C API.</p>
</li>
<li>
<p><a href="https://github.com/zajo/leaf/blob/master/examples/lua_callback_eh.cpp?ts=4">lua_callback_eh.cpp</a>: Transporting arbitrary E-objects through an uncooperative exception-safe API.</p>
</li>
<li>
<p><a href="https://github.com/zajo/leaf/blob/master/examples/exception_to_result.cpp?ts=4">exception_to_result.cpp</a>: Demonstrates how to transport exceptions through a <code>noexcept</code> layer in the program.</p>
</li>
<li>
<p><a href="https://github.com/zajo/leaf/blob/master/examples/error_log.cpp?ts=4">exception_error_log.cpp</a>: Using <code>accumulate</code> to produce an error log.</p>
</li>
<li>
<p><a href="https://github.com/zajo/leaf/blob/master/examples/error_trace.cpp?ts=4">exception_error_trace.cpp</a>: Using <code>accumulate</code> to produce an error trace.</p>
</li>
<li>
<p><a href="https://github.com/zajo/leaf/blob/master/examples/print_half.cpp?ts=4">exception_print_half.cpp</a>: This is a Boost Outcome example translated to LEAF, demonstrating how easy it is to use <a href="#try_handle_some"><code>try_handle_some</code></a> to handle some errors, forwarding any other error to the caller.</p>
</li>
<li>
<p><a href="https://github.com/zajo/leaf/blob/master/examples/asio_beast_leaf_rpc.cpp?ts=4">asio_beast_leaf_rpc.cpp</a>: A simple RPC calculator implemented with Beast+ASIO+LEAF, based on <a href="https://github.com/boostorg/beast/blob/b02f59ff9126c5a17f816852efbbd0ed20305930/example/echo-op/echo_op.cpp">echo_op.cpp</a> and <a href="https://github.com/boostorg/beast/blob/b02f59ff9126c5a17f816852efbbd0ed20305930/example/advanced/server/advanced_server.cpp">advanced_server.cpp</a> (Beast examples).</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect1">
<h2 id="synopsis">Synopsis</h2>
<div class="sectionbody">
<div class="paragraph">
<p>This section lists each public header file in LEAF, documenting the definitions it provides.</p>
</div>
<div class="paragraph">
<p>LEAF headers are organized as to minimize coupling:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Headers needed to report but not handle errors are lighter than headers providing error handling functionality.</p>
</li>
<li>
<p>Headers that provide exception handling or throwing functionality are separate from headers that provide error-handling or reporting but do not use exceptions.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>There is also a reference section split in four parts, the contents of each part organized alphabetically:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="#functions">Reference: Functions</a></p>
</li>
<li>
<p><a href="#types">Reference: Types</a></p>
</li>
<li>
<p><a href="#macros">Reference: Macros</a></p>
</li>
<li>
<p><a href="#traits">Reference: Traits</a></p>
</li>
</ul>
</div>
<hr>
<div class="sect2">
<h3 id="synopsis-reporting">Error Reporting</h3>
<div class="paragraph">
<p>LEAF supports reporting errors via a <code>result&lt;T&gt;</code> type or by throwing exceptions. Functions that throw exceptions or use exception handling are defined in separate headers, so that client code that does not use exceptions is not coupled with them.</p>
</div>
<div class="sect3">
<h4 id="error.hpp"><code>error.hpp</code></h4>
<div class="paragraph">
<p>The header <code>&lt;boost/leaf/error.hpp&gt;</code> contains definitions needed by translation units that report errors but do not throw exceptions.</p>
</div>
<div class="listingblock">
<div class="title">#include &lt;boost/leaf/error.hpp&gt;</div>
<div class="content">
<pre class="highlight nowrap"><code class="language-c++" data-lang="c++">namespace boost { namespace leaf {

  template &lt;class T&gt;
  struct is_e_type
  {
    static constexpr bool value = &lt;&lt;unspecified&gt;&gt;;
  };

  //////////////////////////////////////////

  class error_id
  {
  public:

    error_id() noexcept;

    error_id( std::error_code const &amp; ec ) noexcept;

    int value() const noexcept;
    explicit operator bool() const noexcept;

    std::error_code to_error_code() const noexept;

    friend bool operator==( error_id a, error_id b ) noexcept;
    friend bool operator!=( error_id a, error_id b ) noexcept;
    friend bool operator&lt;( error_id a, error_id b ) noexcept;

    template &lt;class... E&gt;
    error_id load( E &amp;&amp; ... e ) const noexcept;

    template &lt;class... F&gt;
    error_id accumulate( F &amp;&amp; ... f ) const noexcept;

    friend std::ostream &amp; operator&lt;&lt;( std::ostream &amp; os, error_id x );
  };

  bool is_error_id( std::error_code const &amp; ec ) noexcept;

  template &lt;class... E&gt;
  error_id new_error( E &amp;&amp; ... e ) noexcept;

  error_id current_error() noexcept;

  //////////////////////////////////////////

  class polymorphic_context
  {
  protected:

    polymorphic_context() noexcept = default;
    ~polymorphic_context() noexcept = default;

  public:

    virtual void activate() noexcept = 0;
    virtual void deactivate() noexcept = 0;
    virtual bool is_active() const noexcept = 0;

    virtual void propagate() noexcept = 0;

    virtual void print( std::ostream &amp; ) const = 0;
  };

  //////////////////////////////////////////

  template &lt;class Ctx&gt;
  class context_activator
  {
    context_activator( context_activator const &amp; ) = delete;
    context_activator &amp; operator=( context_activator const &amp; ) = delete;

  public:

    explicit context_activator( Ctx &amp; ctx ) noexcept;
    context_activator( context_activator &amp;&amp; ) noexcept;
    ~context_activator() noexcept;
  };

} }

template &lt;class Ctx&gt;
context_activator&lt;Ctx&gt; activate_context( Ctx &amp; ctx ) noexcept;

#define LEAF_NEW_ERROR(...) ....
#define LEAF_AUTO(v,r) ....
#define LEAF_CHECK(r) ....</code></pre>
</div>
</div>
<div class="paragraph text-right">
<p><a href="#is_e_type"><code>is_e_type</code></a> | <a href="#error_id"><code>error_id</code></a> | <a href="#is_error_id"><code>is_error_id</code></a> | <a href="#new_error"><code>new_error</code></a> | <a href="#current_error"><code>current_error</code></a> | <a href="#polymorphic_context"><code>polymorphic_context</code></a> | <a href="#context_activator"><code>context_activator</code></a> | <a href="#activate_context"><code>activate_context</code></a> | <a href="#LEAF_NEW_ERROR"><code>LEAF_NEW_ERROR</code></a> | <a href="#LEAF_AUTO"><code>LEAF_AUTO</code></a> | <a href="#LEAF_CHECK"><code>LEAF_CHECK</code></a></p>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="common.hpp"><code>common.hpp</code></h4>
<div class="paragraph">
<p>This header contains definitions of commonly-used E-types.</p>
</div>
<div class="listingblock">
<div class="title">#include &lt;boost/leaf/common.hpp&gt;</div>
<div class="content">
<pre class="highlight nowrap"><code class="language-c++" data-lang="c++">namespace boost { namespace leaf {

  struct e_api_function    { .... };
  struct e_file_name       { .... };
  struct e_errno           { .... };
  struct e_at_line         { .... };
  struct e_type_info_name  { .... };
  struct e_source_location { .... };

  namespace windows
  {
    struct e_LastError  { .... };
  }

} }</code></pre>
</div>
</div>
<div class="paragraph text-right">
<p><a href="#e_api_function"><code>e_api_function</code></a> | <a href="#e_file_name"><code>e_file_name</code></a> | <a href="#e_errno"><code>e_errno</code></a> | <a href="#e_at_line"><code>e_at_line</code></a> | <a href="#e_type_info_name"><code>e_type_info_name</code></a> | <a href="#e_source_location"><code>e_source_location</code></a> | <a href="#e_LastError"><code>e_LastError</code></a></p>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="result.hpp"><code>result.hpp</code></h4>
<div class="paragraph">
<p>This header defines a lightweight <code>result&lt;T&gt;</code> template. Note that LEAF error-handling functions can work any external type for which the <a href="#is_result_type"><code>is_result_type</code></a> template is specialized, that has value-or-error variant semantics similar to <code>leaf::result&lt;T&gt;</code>.</p>
</div>
<div class="listingblock">
<div class="title">#include &lt;boost/leaf/result.hpp&gt;</div>
<div class="content">
<pre class="highlight nowrap"><code class="language-c++" data-lang="c++">namespace boost { namespace leaf {

  template &lt;class T&gt;
  class result
  {
  public:

    result() noexcept;
    result( T &amp;&amp; v ) noexcept;
    result( T const &amp; v );

    result( error_id err ) noexcept;
    result( std::error_code const &amp; ec ) noexcept;
    result( std::shared_ptr&lt;polymorphic_context&gt; &amp;&amp; ctx ) noexcept;

    result( result &amp;&amp; r ) noexcept;

    template &lt;class U&gt;
    result( result&lt;U&gt; &amp;&amp; r ) noexcept;

    result &amp; operator=( result &amp;&amp; r ) noexcept;

    template &lt;class U&gt;
    result &amp; operator=( result&lt;U&gt; &amp;&amp; r ) noexcept;

    explicit operator bool() const noexcept;

    T const &amp; value() const;
    T &amp; value();

    T const &amp; operator*() const;
    T &amp; operator*();

    T const * operator-&gt;() const;
    T * operator-&gt;();

    &lt;&lt;unspecified-type&gt;&gt; error() noexcept;

    template &lt;class... E&gt;
    error_id load( E &amp;&amp; ... e ) noexcept;

    template &lt;class... F&gt;
    error_id accumulate( F &amp;&amp; ... f );
  };

  struct bad_result: std::exception { };

} }</code></pre>
</div>
</div>
<div class="paragraph text-right">
<p><a href="#result"><code>result</code></a></p>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="preload.hpp"><code>preload.hpp</code></h4>
<div class="paragraph">
<p>This header defines functions for automatic inclusion of E-objects with any error exiting the scope in which they are invoked. See <a href="#tutorial-preload">Using <code>preload</code></a>, <a href="#tutorial-defer">Capturing <code>errno</code> with <code>defer</code></a>, <a href="#tutorial-accumulate">Deferred <code>accumulate</code></a>.</p>
</div>
<div class="paragraph">
<p>The <code>augment_id</code> type is used internally by <code>preload</code>, <code>defer</code> and <code>accumulate</code> to determine the correct <a href="#error_id"><code>error_id</code></a> to associate error objects with.</p>
</div>
<div class="listingblock">
<div class="title">#include &lt;boost/leaf/preload.hpp&gt;</div>
<div class="content">
<pre class="highlight nowrap"><code class="language-c++" data-lang="c++">namespace boost { namespace leaf {

  template &lt;class... E&gt;
  &lt;&lt;unspecified-type&gt;&gt; preload( E &amp;&amp; ... e ) noexcept;

  template &lt;class... F&gt;
  &lt;&lt;unspecified-type&gt;&gt; defer( F &amp;&amp; ... f ) noexcept;

  template &lt;class... F&gt;
  &lt;&lt;unspecified-type&gt;&gt; accumulate( F &amp;&amp; ... f ) noexcept;

  class augment_id
  {
  public:

    augment_id() noexcept;

    error_id check_error() const noexcept;

    template &lt;class... E&gt;
    error_id get_error( E &amp;&amp; ... e ) const noexcept;
  };

} }</code></pre>
</div>
</div>
<div class="paragraph text-right">
<p><a href="#preload"><code>preload</code></a> | <a href="#defer"><code>defer</code></a> | <a href="#accumulate"><code>accumulate</code></a> | <a href="#augment_id"><code>augment_id</code></a></p>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="exception.hpp"><code>exception.hpp</code></h4>
<div class="paragraph">
<p>This header provides support for throwing exceptions.</p>
</div>
<div class="listingblock">
<div class="title">#include &lt;boost/leaf/exception.hpp&gt;</div>
<div class="content">
<pre class="highlight nowrap"><code class="language-c++" data-lang="c++">#include &lt;boost/leaf/error.hpp&gt;

namespace boost { namespace leaf {

  template &lt;class Ex, class... E&gt;
  &lt;&lt;unspecified&gt;&gt; exception( Ex &amp;&amp; ex, E &amp;&amp; ... e ) noexcept;

} }

#define LEAF_EXCEPTION(...) ....

#define LEAF_THROW(...) ....</code></pre>
</div>
</div>
<div class="paragraph text-right">
<p><a href="#exception"><code>exception</code></a> | <a href="#LEAF_EXCEPTION"><code>LEAF_EXCEPTION</code></a> | <a href="#LEAF_THROW"><code>LEAF_THROW</code></a></p>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="_capture_hpp"><code>capture.hpp</code></h4>
<div class="paragraph">
<p>This header is used when transporting E-objects between threads, or to convert exceptions to <code><a href="#result">result</a>&lt;T&gt;</code>.</p>
</div>
<div class="listingblock">
<div class="title">#include &lt;boost/leaf/capture_exception.hpp&gt;</div>
<div class="content">
<pre class="highlight nowrap"><code class="language-c++" data-lang="c++">namespace boost { namespace leaf {

  template &lt;class F, class... A&gt;
  decltype(std::declval&lt;F&gt;()(std::forward&lt;A&gt;(std::declval&lt;A&gt;())...))
  capture(std::shared_ptr&lt;polymorphic_context&gt; &amp;&amp; ctx, F &amp;&amp; f, A... a);

  template &lt;class... Ex, class F&gt;
  &lt;&lt;result&lt;T&gt;-deduced&gt;&gt; exception_to_result( F &amp;&amp; f ) noexcept;

} }</code></pre>
</div>
</div>
<div class="paragraph text-right">
<p><a href="#capture"><code>capture</code></a> | <a href="#exception_to_result"><code>exception_to_result</code></a></p>
</div>
<hr>
</div>
</div>
<div class="sect2">
<h3 id="tutorial-handling">Error Handling</h3>
<div class="paragraph">
<p>Error-handling headers are designed to minimize coupling:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Translation units that work with <code>context</code> objects but do not handle errors should <code>#include &lt;boost/leaf/context.hpp&gt;</code>;</p>
</li>
<li>
<p>Translation units that handle errors but <strong>do not</strong> catch exceptions should <code>#include &lt;boost/leaf/handle_error.hpp&gt;</code>;</p>
</li>
<li>
<p>Translation units that <strong>do</strong> catch exceptions should <code>#include &lt;boost/leaf/handle_exception.hpp&gt;</code>.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Namespace-scope error-handling functions contain the word <code>try_</code> in their name and use the following conventions:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Functions that <strong>do not</strong> use the <code>remote_</code> prefix take a list of error handlers; functions that <strong>do</strong>, take a single error-handling function, which internally captures the list of error handlers. See <a href="#tutorial-remote_handlers">Working with Remote Handlers</a>.</p>
</li>
<li>
<p>Functions that are designed to work with a <code>result&lt;T&gt;</code> type (see <a href="#is_result_type"><code>is_result_type</code></a>) use the <code>_all</code> or <code>_some</code> suffix; the former require (at compile time) the user-supplied set of handlers to definitely handle any reported error, while the latter allow for handlers to recognize and handle some errors, forwarding others to the caller.</p>
</li>
<li>
<p>An <code>_all</code> or a <code>_some</code> function does not catch or handle exceptions unless at least one of the user-supplied handlers uses the <a href="#catch_"><code>catch_</code></a> template. All other error-handling functions catch or can handle exceptions.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>This is summarized in the table below:</p>
</div>
<table class="tableblock frame-all grid-all stripes-none stretch">
<caption class="title">Table 1. Namespace-Scope Error-Handling Functions</caption>
<colgroup>
<col style="width: 33.3333%;">
<col style="width: 33.3333%;">
<col style="width: 33.3334%;">
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">Handles <code>result&lt;T&gt;</code> Errors</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">Handles Exceptions</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">[<code><a href="#remote_try_handle_all">remote_</a></code>]<a href="#try_handle_all"><code>try_handle_all</code></a></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">Yes</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">*</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">[<code><a href="#remote_try_handle_some">remote_</a></code>]<a href="#try_handle_some"><code>try_handle_some</code></a></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">Yes</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">*</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">[<code><a href="#remote_try_catch">remote_</a></code>]<a href="#try_catch"><code>try_catch</code></a></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">No</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">Yes</p></td>
</tr>
</tbody>
</table>
<div class="paragraph text-right">
<p>* Handles exceptions iff at least one of the supplied handlers uses <a href="#catch_"><code>catch_</code></a><br>
(Dispatched statically; please <code>#include &lt;boost/leaf/handle_exception.hpp&gt;</code>)</p>
</div>
<div class="paragraph">
<p>The above error-handling functions:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Create an internal <code>context&lt;E&#8230;&#8203;&gt;</code> object <code>ctx</code>, deducing the <code>E&#8230;&#8203;</code> types automatically from the arguments of the supplied handlers;</p>
</li>
<li>
<p>Attempt the set of operations contained in the passed <code>TryBlock</code> function;</p>
</li>
<li>
<p>If that fails, they invoke an appropriate error handler to handle the error.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>In addition, the <code>context</code> template provides lower-level error handling member functions, <a href="#context::handle_error"><code>handle_error</code></a> and <a href="#context::remote_handle_error"><code>remote_handle_error</code></a>, which select an error handler based on available error objects in <code>*this</code>, associated with a supplied <a href="#error_id"><code>error_id</code></a>. These functions are designed to be called after the caller has detected a failure; they do not use a <code>result</code> type and can not deal with exceptions. Use one of the <code>try_</code> functions (above) for these cases.</p>
</div>
<hr>
<div class="sect3">
<h4 id="context.hpp"><code>context.hpp</code></h4>
<div class="paragraph">
<p>This header defines the <code>context</code> template, which is used in error-handling scopes to provide storage for the error objects needed by user-defined error-handling functions, and to handle errors.</p>
</div>
<div class="listingblock">
<div class="title">#include &lt;boost/leaf/context.hpp&gt;</div>
<div class="content">
<pre class="highlight nowrap"><code class="language-c++" data-lang="c++">namespace boost { namespace leaf {

  template &lt;class... E&gt;
  class context
  {
    context( context const &amp; ) = delete;
    context &amp; operator=( context const &amp; ) = delete;

  public:

    context() noexcept;
    context( context &amp;&amp; x ) noexcept;
    ~context() noexcept;

    void activate() noexcept;
    void deactivate() noexcept;
    bool is_active() const noexcept;

    void propagate () noexcept;

    void print( std::ostream &amp; os ) const;

    template &lt;class R, class... H&gt;
    R handle_error( R &amp;, H &amp;&amp; ... ) const;

    template &lt;class R, class RemoteH&gt;
    R remote_handle_error( R &amp;, RemoteH &amp;&amp; ) const;
  };

  //////////////////////////////////////////

  template &lt;class RemoteH&gt;
  using context_type_from_remote_handler = typename &lt;&lt;unspecified&gt;&gt;::type;

  template &lt;class RemoteH&gt;
  context_type_from_remote_handler&lt;RemoteH&gt; make_context( RemoteH const * = 0 );

  template &lt;class RemoteH&gt;
  std::shared_ptr&lt;polymorphic_context&gt; make_shared_context( RemoteH const * = 0 );

  template &lt;class RemoteH, class Alloc&gt;
  std::shared_ptr&lt;polymorphic_context&gt; allocate_shared_context( Alloc alloc, RemoteH const * = 0 );

} }</code></pre>
</div>
</div>
<div class="paragraph text-right">
<p><a href="#context"><code>context</code></a> | <a href="#context_type_from_remote_handler"><code>context_type_from_remote_handler</code></a> | <a href="#make_context"><code>make_context</code></a> | <a href="#make_shared_context"><code>make_shared_context</code></a> | <a href="#allocate_shared_context"><code>allocate_shared_context</code></a></p>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="handle_error.hpp"><code>handle_error.hpp</code></h4>
<div class="paragraph">
<p>This header defines functions and types that can be used to handle errors but not catch exceptions.</p>
</div>
<div class="listingblock">
<div class="title">#include &lt;boost/leaf/handle_error.hpp&gt;</div>
<div class="content">
<pre class="highlight nowrap"><code class="language-c++" data-lang="c++">#include &lt;boost/leaf/context.hpp&gt;

namespace boost { namespace leaf {

  template &lt;class TryBlock, class... H&gt;
  typename std::decay&lt;decltype(std::declval&lt;TryBlock&gt;()().value())&gt;::type
  try_handle_all( TryBlock &amp;&amp; try_block, H &amp;&amp; ... h );

  template &lt;class TryBlock, class... H&gt;
  typename std::decay&lt;decltype(std::declval&lt;TryBlock&gt;()())&gt;::type
  try_handle_some( TryBlock &amp;&amp; try_block, H &amp;&amp; ... h );

  template &lt;class TryBlock, class RemoteH&gt;
  typename std::decay&lt;decltype(std::declval&lt;TryBlock&gt;()().value())&gt;::type
  remote_try_handle_all( TryBlock &amp;&amp; try_block, RemoteH &amp;&amp; h );

  template &lt;class TryBlock, class RemoteH&gt;
  typename std::decay&lt;decltype(std::declval&lt;TryBlock&gt;()())&gt;::type
  remote_try_handle_some( TryBlock &amp;&amp; try_block, RemoteH &amp;&amp; h );

  //////////////////////////////////////////

  template &lt;class Enum&gt;
  class match;

  template &lt;class Enum, class ErrorConditionEnum = Enum&gt;
  struct condition;

  //////////////////////////////////////////

  class error_info
  {
    //Constructors unspecified

  public:

    error_id error() const noexcept;

    bool exception_caught() const noexcept;
    std::exception const * exception() const noexcept;

    friend std::ostream &amp; operator&lt;&lt;( std::ostream &amp; os, error_info const &amp; x );
  };

  class diagnostic_info: public error_info
  {
    //Constructors unspecified

    friend std::ostream &amp; operator&lt;&lt;( std::ostream &amp; os, diagnostic_info const &amp; x );
  };

  class verbose_diagnostic_info: public error_info
  {
    //Constructors unspecified

    friend std::ostream &amp; operator&lt;&lt;( std::ostream &amp; os, diagnostic_info const &amp; x );
  };

} }</code></pre>
</div>
</div>
<div class="paragraph text-right">
<p><a href="#context.hpp"><code>context.hpp</code></a> | [<a href="#remote_try_handle_all"><code>remote_</code></a>]<a href="#try_handle_all"><code>try_handle_all</code></a> | [<a href="#remote_try_handle_some"><code>remote_</code></a>]<a href="#try_handle_some"><code>try_handle_some</code></a> | <a href="#match"><code>match</code></a> | <a href="#condition"><code>condition</code></a> | <a href="#error_info"><code>error_info</code></a> | <a href="#diagnostic_info"><code>diagnostic_info</code></a> | <a href="#verbose_diagnostic_info"><code>verbose_diagnostic_info</code></a></p>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="handle_exception.hpp"><code>handle_exception.hpp</code></h4>
<div class="paragraph">
<p>This header:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Defines namespace-scope functions and types that can be used to catch exceptions.</p>
</li>
<li>
<p>Enables all functions using the <code>_some</code> or <code>_all</code> suffix (defined in <a href="#handle_error.hpp"><code>handle_error.hpp</code></a>) to handle exceptions, not only failures communicated by <code>result&lt;T&gt;</code>.</p>
</li>
</ul>
</div>
<div class="listingblock">
<div class="title">#include &lt;boost/leaf/handle_exception.hpp&gt;</div>
<div class="content">
<pre class="highlight nowrap"><code class="language-c++" data-lang="c++">#include &lt;boost/leaf/handle_error.hpp&gt;

namespace boost { namespace leaf {

  template &lt;class TryBlock, class... H&gt;
  typename std::decay&lt;decltype(std::declval&lt;TryBlock&gt;()())&gt;::type
  try_catch( TryBlock &amp;&amp; try_block, H &amp;&amp; ... h );

  template &lt;class TryBlock, class RemoteH&gt;
  typename std::decay&lt;decltype(std::declval&lt;TryBlock&gt;()())&gt;::type
  remote_try_catch( TryBlock &amp;&amp; try_block, RemoteH &amp;&amp; h );

  //////////////////////////////////////////

  template &lt;class... Ex&gt;
  struct catch_;

} }</code></pre>
</div>
</div>
<div class="paragraph text-right">
<p><a href="#handle_error.hpp"><code>handle_error.hpp</code></a> | [<a href="#remote_try_catch"><code>remote_</code></a>]<a href="#try_catch"><code>try_catch</code></a> | <a href="#catch_"><code>catch_</code></a></p>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="traits">Reference: Traits</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="is_e_type"><code>is_e_type</code></h3>
<div class="listingblock">
<div class="title">#include &lt;boost/leaf/error.hpp&gt;</div>
<div class="content">
<pre class="highlight nowrap"><code class="language-c++" data-lang="c++">namespace boost { namespace leaf {

  template &lt;class E&gt;
  struct is_e_type
  {
    static constexpr bool value = &lt;&lt;exact_definition_unspecified&gt;&gt;;
  };

} }</code></pre>
</div>
</div>
<div class="paragraph">
<p>Users specialize the <code>is_e_type</code> template to register error types with LEAF; see <a href="#tutorial-is_e_type">E-types</a>.</p>
</div>
<div class="paragraph">
<p>The default <code>is_e_type</code> template defines <code>value</code> as <code>true</code> for:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Any type which defines an accessible data member <code>value</code>;</p>
</li>
<li>
<p>Any type <code>E</code> for which <code>std::is_base_of&lt;std::exception, E&gt;::value</code> is <code>true</code> (see <a href="#exception_to_result"><code>exception_to_result</code></a>);</p>
</li>
<li>
<p><code>std::exception_ptr</code>.</p>
</li>
</ul>
</div>
<hr>
</div>
<div class="sect2">
<h3 id="is_result_type"><code>is_result_type</code></h3>
<div class="listingblock">
<div class="title">#include &lt;boost/leaf/error.hpp&gt;&gt;</div>
<div class="content">
<pre class="highlight nowrap"><code class="language-c++" data-lang="c++">namespace boost { namespace leaf {

  template &lt;class R&gt;
  struct is_result_type: std::false_type
  {
  };

} }</code></pre>
</div>
</div>
<div class="paragraph">
<p>The error-handling functionality provided by <a href="#try_handle_some"><code>try_handle_some</code></a>, <a href="#try_handle_all"><code>try_handle_all</code></a> and <a href="#try_catch"><code>try_catch</code></a>&#8201;&#8212;&#8201;including the ability to <a href="#tutorial-loading">load</a> error objects of arbitrary types&#8201;&#8212;&#8201;is compatible with any external &#8220;result&lt;T&gt;&#8221; type R, as long as for a given object <code>r</code> of type <code>R</code>:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>If <code>bool(r)</code> is <code>true</code>, <code>r</code> indicates success, in which case it is valid to call <code>r.value()</code> to recover the &#8220;T&#8221; value.</p>
</li>
<li>
<p>Otherwise <code>r</code> indicates a failure, in which case it is valid to call <code>r.error()</code>. The returned value is used to initialize an <code>error_id</code> (note: <code>error_id</code> can be initialized by <code>std::error_code</code>).</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>To use an external &#8220;result&lt;T&gt;&#8221;  type R, you must specialize the <code>is_result_type</code> template so that <code>is_result_type&lt;R&gt;::value</code> evaluates to <code>true</code>.</p>
</div>
<div class="paragraph">
<p>Naturally, the provided <code>leaf::<a href="#result">result</a>&lt;T&gt;</code> class template satisfies these requirements. In addition, it allows error objects to be transported across thread boundaries, using a <code>std::shared_ptr&lt;<a href="#polymorphic_context">polymorphic_context</a>&gt;</code>.</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="functions">Reference: Functions</h2>
<div class="sectionbody">
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
The contents of each Reference section are organized alphabetically.
</td>
</tr>
</table>
</div>
<hr>
<div class="sect2">
<h3 id="accumulate"><code>accumulate</code></h3>
<div class="listingblock">
<div class="title">#include &lt;boost/leaf/preload.hpp&gt;</div>
<div class="content">
<pre class="highlight nowrap"><code class="language-c++" data-lang="c++">namespace boost { namespace leaf {

  template &lt;class... F&gt;
  &lt;&lt;unspecified-type&gt;&gt; accumulate( F &amp;&amp; ... f ) noexcept;

} }</code></pre>
</div>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">Requirements: </dt>
<dd>
<p>Each of <code>f<sub>i</sub></code> in <code>f&#8230;&#8203;</code> must be a function that does not throw exceptions and takes a single argument of type <code>E<sub>i</sub></code> such that:</p>
<div class="ulist">
<ul>
<li>
<p><code>E<sub>i</sub></code> defines an accessible no-throw default constructor, and</p>
</li>
<li>
<p><code><a href="#is_e_type">is_e_type</a>&lt;E<sub>i</sub>&gt;::value</code> is <code>true</code>.</p>
</li>
</ul>
</div>
</dd>
<dt class="hdlist1">Effects: </dt>
<dd>
<p>All <code>f&#8230;&#8203;</code> objects are forwarded and stored into the returned object of unspecified type, which should be captured by <code>auto</code> and kept alive in the calling scope. When that object is destroyed:</p>
<div class="openblock">
<div class="content">
<div class="ulist">
<ul>
<li>
<p>If <a href="#new_error"><code>new_error</code></a> was invoked (by the calling thread) since the object returned by <code>accumulate</code> was created, each of the stored <code>f&#8230;&#8203;</code> is called with the corresponding E-object currently uniquely associated with <a href="#current_error"><code>current_error</code></a>, or with a new default-initialized instance of that E-type if no such E-object currently exists;</p>
</li>
<li>
<p>Otherwise, if <code>std::unhandled_exception()</code> returns <code>true</code>, each of the stored <code>f&#8230;&#8203;</code> is called with the corresponding E-object currently uniquely associated with the value returned by <a href="#new_error"><code>new_error</code></a>, or with a new default-initialized instance of that E-type if no such E-object currently exists.</p>
</li>
</ul>
</div>
</div>
</div>
<div class="paragraph">
<p>The stored <code>f&#8230;&#8203;</code> objects are discarded.</p>
</div>
</dd>
</dl>
</div>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<i class="fa icon-warning" title="Warning"></i>
</td>
<td class="content">
It is critical that the passed functions do not throw exceptions: they are called from within a destructor.
</td>
</tr>
</table>
</div>
<div class="admonitionblock caution">
<table>
<tr>
<td class="icon">
<i class="fa icon-caution" title="Caution"></i>
</td>
<td class="content">
Be extra careful, since <a href="#tutorial-accumulation">Accumulation</a> naturally may need to allocate memory. In this case consider using <a href="#error_id::accumulate"><code>error_id::accumulate</code></a> or <a href="#result::accumulate"><code>result::accumulate</code></a> instead, invoked <strong>not</strong> from a destructor, in which case throwing exceptions would be okay.
</td>
</tr>
</table>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
See also <a href="#tutorial-accumulate">Deferred <code>accumulate</code></a> from the Tutorial.
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect2">
<h3 id="activate_context"><code>activate_context</code></h3>
<div class="listingblock">
<div class="title">#include &lt;boost/leaf/error.hpp&gt;</div>
<div class="content">
<pre class="highlight nowrap"><code class="language-c++" data-lang="c++">namespace boost { namespace leaf {

  template &lt;class Ctx&gt;
  context_activator&lt;Ctx&gt; activate_context( Ctx &amp; ctx ) noexcept
  {
    return context_activator&lt;Ctx&gt;(ctx);
  }

} }</code></pre>
</div>
</div>
<hr>
</div>
<div class="sect2">
<h3 id="allocate_shared_context"><code>allocate_shared_context</code></h3>
<div class="listingblock">
<div class="title">#include &lt;boost/leaf/context.hpp&gt;</div>
<div class="content">
<pre class="highlight nowrap"><code class="language-c++" data-lang="c++">namespace boost { namespace leaf {

  template &lt;class RemoteH, class Alloc&gt;
  std::shared_ptr&lt;polymorphic_context&gt; allocate_shared_context( Alloc alloc, RemoteH const * = 0 )
  {
    return std::allocate_shared&lt;context_type_from_remote_handler&lt;RemoteH&gt;&gt;(alloc);
  }

} }</code></pre>
</div>
</div>
<div class="paragraph text-right">
<p><a href="#context_type_from_remote_handler"><code>context_type_from_remote_handler</code></a></p>
</div>
<hr>
</div>
<div class="sect2">
<h3 id="capture"><code>capture</code></h3>
<div class="listingblock">
<div class="title">#include &lt;boost/leaf/capture_result.hpp&gt;</div>
<div class="content">
<pre class="highlight nowrap"><code class="language-c++" data-lang="c++">namespace boost { namespace leaf {

  template &lt;class F, class... A&gt;
  decltype(std::declval&lt;F&gt;()(std::forward&lt;A&gt;(std::declval&lt;A&gt;())...))
  capture(std::shared_ptr&lt;polymorphic_context&gt; &amp;&amp; ctx, F &amp;&amp; f, A... a);

} }</code></pre>
</div>
</div>
<div class="paragraph">
<p>This function can be used to capture E-objects stored in a <a href="#context"><code>context</code></a> in one thread and transport them to a different thread for handling, either in a <code><a href="#result">result</a>&lt;T&gt;</code> object or in an exception.</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">Returns: </dt>
<dd>
<p>The same type returned by <code>F</code>.</p>
</dd>
<dt class="hdlist1">Effects: </dt>
<dd>
<p>Uses an internal <a href="#context_activator"><code>context_activator</code></a> to <a href="#context::activate"><code>activate</code></a> <code>*ctx</code>, then invokes <code>std::forward&lt;F&gt;(f)(std::forward&lt;A&gt;(a)&#8230;&#8203;)</code>. Then:</p>
<div class="openblock">
<div class="content">
<div class="ulist">
<ul>
<li>
<p>If the returned value <code>r</code> is not a <code>result&lt;T&gt;</code> type (see <a href="#is_result_type"><code>is_result_type</code></a>), it is forwarded to the caller.</p>
</li>
<li>
<p>Otherwise:</p>
<div class="ulist">
<ul>
<li>
<p>If <code>!r</code>, the return value of <code>capture</code> is initialized with <code>ctx</code>;</p>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
An object of type <code>leaf::<a href="#result">result</a>&lt;T&gt;</code> can be initialized with a <code>std::shared_ptr&lt;leaf::polymorphic_context&gt;</code>.
</td>
</tr>
</table>
</div>
</li>
<li>
<p>otherwise, it is initialized with <code>r</code>.</p>
</li>
</ul>
</div>
</li>
</ul>
</div>
</div>
</div>
<div class="paragraph">
<p>In case <code>f</code> throws, <code>capture</code> catches the exception in a <code>std::exception_ptr</code>, and throws a different exception of unspecified type that transports both the <code>std::exception_ptr</code> as well as <code>ctx</code>. This exception type is recognized by <a href="#try_catch"><code>try_catch</code></a>, which automatically unpacks the original exception and propagates the contents of <code>*ctx</code> (presumably, in a different thread).</p>
</div>
</dd>
</dl>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
See also <a href="#tutorial-async">Transporting Error Objects Between Threads</a> from the Tutorial.
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect2">
<h3 id="context_type_from_remote_handler"><code>context_type_from_remote_handler</code></h3>
<div class="listingblock">
<div class="title">#include &lt;boost/leaf/context.hpp&gt;</div>
<div class="content">
<pre class="highlight nowrap"><code class="language-c++" data-lang="c++">namespace boost { namespace leaf {

  template &lt;class RemoteH&gt;
  using context_type_from_remote_handler = typename &lt;&lt;unspecified&gt;&gt;::type;

} }</code></pre>
</div>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">Example Usage: </dt>
<dd>
<div class="listingblock">
<div class="content">
<pre class="highlight nowrap"><code class="language-c++" data-lang="c++">auto handle_error = []( leaf::error_info const &amp; error )
{
  return leaf::handle_all( error,
    []( e_this const &amp; a, e_that const &amp; b )
    {
      ....
    },
    []( leaf::diagnostic_info const &amp; info )
    {
      ....
    },
    .... );
};

leaf::context_type_from_remote_handler&lt;decltype(handle_error)&gt; ctx;</code></pre>
</div>
</div>
<div class="paragraph text-right">
<p><a href="#error_info"><code>error_info</code></a> | <a href="#diagnostic_info"><code>diagnostic_info</code></a></p>
</div>
<div class="paragraph">
<p>In the example above, <code>ctx</code> will be of type <code>context&lt;e_this, e_that, leaf::diagnostic_info&gt;</code>, deduced automatically from the handler list in <code>handle_error</code>. This guarantees that <code>ctx</code> provides storage for all E-types that are required by <code>handle_error</code> in order to handle errors.</p>
</div>
</dd>
</dl>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
Alternatively, a suitable context may be created by calling <a href="#make_context"><code>make_context</code></a>, or allocated dynamically by calling <a href="#make_shared_context"><code>make_shared_context</code></a> or <a href="#allocate_shared_context"><code>allocate_shared_context</code></a>.
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect2">
<h3 id="current_error"><code>current_error</code></h3>
<div class="listingblock">
<div class="title">#include &lt;boost/leaf/error.hpp&gt;</div>
<div class="content">
<pre class="highlight nowrap"><code class="language-c++" data-lang="c++">namespace boost { namespace leaf {

  error_id current_error() noexcept;

} }</code></pre>
</div>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">Returns: </dt>
<dd>
<p>The <code>error_id</code> value returned the last time <a href="#new_error"><code>new_error</code></a> was invoked from the calling thread.</p>
</dd>
</dl>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
See also <a href="#preload"><code>preload</code></a> / <a href="#defer"><code>defer</code></a> / <a href="#accumulate"><code>accumulate</code></a>.
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect2">
<h3 id="defer"><code>defer</code></h3>
<div class="listingblock">
<div class="title">#include &lt;boost/leaf/preload.hpp&gt;</div>
<div class="content">
<pre class="highlight nowrap"><code class="language-c++" data-lang="c++">namespace boost { namespace leaf {

  template &lt;class... F&gt;
  &lt;&lt;unspecified-type&gt;&gt; defer( F &amp;&amp; ... f ) noexcept;

} }</code></pre>
</div>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">Requirements: </dt>
<dd>
<p>Each of <code>f<sub>i</sub></code> in <code>f&#8230;&#8203;</code> must be a function that does not throw exceptions, takes no arguments and returns an object of a no-throw movable type <code>E<sub>i</sub></code> for which <code><a href="#is_e_type">is_e_type</a>&lt;E<sub>i</sub>&gt;::value</code> is <code>true</code>.</p>
</dd>
<dt class="hdlist1">Effects: </dt>
<dd>
<p>All <code>f&#8230;&#8203;</code> objects are forwarded and stored into the returned object of unspecified type, which should be captured by <code>auto</code> and kept alive in the calling scope. When that object is destroyed:</p>
<div class="openblock">
<div class="content">
<div class="ulist">
<ul>
<li>
<p>If <a href="#new_error"><code>new_error</code></a> was invoked (by the calling thread) since the object returned by <code>defer</code> was created, each of the stored <code>f&#8230;&#8203;</code> is called, and each returned object is <a href="#tutorial-loading">loaded</a> and uniquely associated with  <a href="#current_error"><code>current_error</code></a>;</p>
</li>
<li>
<p>Otherwise, if <code>std::unhandled_exception()</code> returns <code>true</code>, each of the stored <code>f&#8230;&#8203;</code> is called, and each returned object is loaded and uniquely associated with the value returned by <a href="#new_error"><code>new_error</code></a>.</p>
</li>
</ul>
</div>
</div>
</div>
<div class="paragraph">
<p>The stored <code>f&#8230;&#8203;</code> objects are discarded.</p>
</div>
</dd>
</dl>
</div>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<i class="fa icon-warning" title="Warning"></i>
</td>
<td class="content">
It is critical that the passed functions do not throw exceptions: they are called from within a destructor.
</td>
</tr>
</table>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
See also <a href="#tutorial-defer">Capturing <code>errno</code> with <code>defer</code></a> from the tutorial.
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect2">
<h3 id="exception"><code>exception</code></h3>
<div class="listingblock">
<div class="title">#include &lt;boost/leaf/exception.hpp&gt;</div>
<div class="content">
<pre class="highlight nowrap"><code class="language-c++" data-lang="c++">namespace boost { namespace leaf {

  template &lt;class Ex, class... E&gt;
  &lt;&lt;unspecified&gt;&gt; exception( Ex &amp;&amp; ex, E &amp;&amp; ... e ) noexcept;

} }</code></pre>
</div>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">Requirements: </dt>
<dd>
<div class="ulist">
<ul>
<li>
<p><code>Ex</code> must derive from <code>std::exception</code>.</p>
</li>
<li>
<p>For each <code>E</code><sub>i</sub> in <code>E&#8230;&#8203;</code>, <code><a href="#is_e_type">is_e_type</a>&lt;E<sub>i</sub>&gt;::value</code> is <code>true</code>.</p>
</li>
</ul>
</div>
</dd>
<dt class="hdlist1">Returns: </dt>
<dd>
<p>An object of unspecified type which derives publicly from <code>Ex</code> <strong>and</strong> from class <a href="#error_id"><code>error_id</code></a> such that:</p>
<div class="ulist">
<ul>
<li>
<p>its <code>Ex</code> subobject is initialized by <code>std::forward&lt;Ex&gt;(ex)</code>;</p>
</li>
<li>
<p>its <code>error_id</code> subobject is initialized by <code><a href="#new_error">new_error</a>(std::forward&lt;E&gt;(e)&#8230;&#8203;</code>).</p>
</li>
</ul>
</div>
</dd>
</dl>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
If thrown, the returned object can be caught as <code>Ex &amp;</code> or as <code>leaf::<a href="#error_id">error_id</a> &amp;</code>.
</td>
</tr>
</table>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
To automatically capture <code>__FILE__</code>, <code>__LINE__</code> and <code>__FUNCTION__</code> with the returned object, use <a href="#LEAF_EXCEPTION"><code>LEAF_EXCEPTION</code></a> instead of <code>leaf::exception</code>.
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect2">
<h3 id="exception_to_result"><code>exception_to_result</code></h3>
<div class="listingblock">
<div class="title">#include &lt;boost/leaf/capture.hpp&gt;</div>
<div class="content">
<pre class="highlight nowrap"><code class="language-c++" data-lang="c++">namespace boost { namespace leaf {

  template &lt;class... Ex, class F&gt;
  &lt;&lt;result&lt;T&gt;-deduced&gt;&gt; exception_to_result( F &amp;&amp; f ) noexcept;

} }</code></pre>
</div>
</div>
<div class="paragraph">
<p>This function can be used to catch exceptions from a lower-level library and convert them to <code><a href="#result">result</a>&lt;T&gt;</code>.</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">Returns: </dt>
<dd>
<p>If <code>f</code> returns <code>T</code>, <code>exception_to_result</code> returns <code>result&lt;T&gt;</code>.</p>
</dd>
<dt class="hdlist1">Effects: </dt>
<dd>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Catches all exceptions, then captures <code>std::current_exception</code> in a <code>std::exception_ptr</code> object, which is <a href="#tutorial-loading">loaded</a> with the returned <code>result&lt;T&gt;</code>.</p>
</li>
<li>
<p>Attempts to convert the caught exception, using <code>dynamic_cast</code>, to each type <code>Ex<sub>i</sub></code> in <code>Ex&#8230;&#8203;</code>. If the cast to <code>Ex<sub>i</sub></code> succeeds, the <code>Ex<sub>i</sub></code> slice of the caught exception is loaded with the returned <code>result&lt;T&gt;</code>.</p>
</li>
</ol>
</div>
</dd>
</dl>
</div>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<i class="fa icon-warning" title="Warning"></i>
</td>
<td class="content">
Handlers passed to <a href="#try_handle_some"><code>try_handle_some</code></a> / <a href="#try_handle_all"><code>try_handle_all</code></a> should take the converted-to-result exception objects by <code>const &amp;</code> (whereas, in case exceptions are handled directly by <a href="#try_catch"><code>try_catch</code></a> handlers, <a href="#catch_"><code>catch_</code></a> should be used instead).
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight nowrap"><code class="language-c++" data-lang="c++">int compute_answer_throws();

//Call compute_answer, convert exceptions to result&lt;int&gt;
leaf::result&lt;int&gt; compute_answer()
{
  return leaf::exception_to_result&lt;ex_type1, ex_type2&gt;(compute_answer_throws());
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Later, what used to be the exception types <code>ex_type1</code> and <code>ex_type2</code> can be handled by <a href="#try_handle_some"><code>try_handle_some</code></a> / <a href="#try_handle_all"><code>try_handle_all</code></a>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight nowrap"><code class="language-c++" data-lang="c++">return leaf::try_handle_some(

  [] -&gt; leaf::result&lt;void&gt;
  {
    LEAF_AUTO(answer, compute_answer());
    //Use answer
    ....
    return { };
  },

  []( ex_type1 const &amp; ex1 )
  {
    //Handle ex_type1
    ....
    return { };
  },

  []( ex_type2 const &amp; ex2 )
  {
    //Handle ex_type2
    ....
    return { };
  },

  []( std::exception_ptr const &amp; p )
  {
    //Handle any other exception from compute_answer.
    ....
    return { };
  } );</code></pre>
</div>
</div>
<div class="paragraph text-right">
<p><a href="#try_handle_some"><code>try_handle_some</code></a> | <a href="#result"><code>result</code></a> | <a href="#LEAF_AUTO"><code>LEAF_AUTO</code></a></p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
See also <a href="#tutorial-exception_to_result">Converting Exceptions to <code>result&lt;T&gt;</code></a> from the tutorial.
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect2">
<h3 id="make_context"><code>make_context</code></h3>
<div class="listingblock">
<div class="title">#include &lt;boost/leaf/context.hpp&gt;</div>
<div class="content">
<pre class="highlight nowrap"><code class="language-c++" data-lang="c++">namespace boost { namespace leaf {

  template &lt;class RemoteH&gt;
  context_type_from_remote_handler&lt;RemoteH&gt; make_context( RemoteH const * = 0 )
  {
    return { };
  }

} }</code></pre>
</div>
</div>
<div class="paragraph text-right">
<p><a href="#context_type_from_remote_handler"><code>context_type_from_remote_handler</code></a></p>
</div>
<hr>
</div>
<div class="sect2">
<h3 id="make_shared_context"><code>make_shared_context</code></h3>
<div class="listingblock">
<div class="title">#include &lt;boost/leaf/context.hpp&gt;</div>
<div class="content">
<pre class="highlight nowrap"><code class="language-c++" data-lang="c++">namespace boost { namespace leaf {

  template &lt;class RemoteH&gt;
  std::shared_ptr&lt;polymorphic_context&gt; make_shared_context( RemoteH const * = 0 )
  {
    return std::make_shared&lt;context_type_from_remote_handler&lt;RemoteH&gt;&gt;();
  }

} }</code></pre>
</div>
</div>
<div class="paragraph text-right">
<p><a href="#context_type_from_remote_handler"><code>context_type_from_remote_handler</code></a></p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
See also <a href="#tutorial-async">Transporting Error Objects Between Threads</a> from the tutorial.
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect2">
<h3 id="new_error"><code>new_error</code></h3>
<div class="listingblock">
<div class="title">#include &lt;boost/leaf/error.hpp&gt;</div>
<div class="content">
<pre class="highlight nowrap"><code class="language-c++" data-lang="c++">namespace boost { namespace leaf {

  template &lt;class... E&gt;
  error_id new_error( E &amp;&amp; ... e ) noexcept;

} }</code></pre>
</div>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">Requirements: </dt>
<dd>
<p><code><a href="#is_e_type">is_e_type</a>&lt;E&gt;::value</code> must be <code>true</code> for each <code>E</code>.</p>
</dd>
<dt class="hdlist1">Effects: </dt>
<dd>
<p>Each of the <code>e&#8230;&#8203;</code> objects is <a href="#tutorial-loading">loaded</a> and uniquely associated with the returned value.</p>
</dd>
<dt class="hdlist1">Returns: </dt>
<dd>
<p>A new <code>error_id</code> value, which is unique across the entire program.</p>
</dd>
<dt class="hdlist1">Ensures: </dt>
<dd>
<p><code>id.value()!=0</code>, where <code>id</code> is the returned <code>error_id</code>.</p>
</dd>
</dl>
</div>
<hr>
</div>
<div class="sect2">
<h3 id="preload"><code>preload</code></h3>
<div class="listingblock">
<div class="title">#include &lt;boost/leaf/preload.hpp&gt;</div>
<div class="content">
<pre class="highlight nowrap"><code class="language-c++" data-lang="c++">namespace boost { namespace leaf {

  template &lt;class... E&gt;
  &lt;&lt;unspecified-type&gt;&gt; preload( E &amp;&amp; ... e ) noexcept;

} }</code></pre>
</div>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">Requirements: </dt>
<dd>
<p><code><a href="#is_e_type">is_e_type</a>&lt;E&gt;::value</code> must be <code>true</code> for each <code>E</code>.</p>
</dd>
<dt class="hdlist1">Effects: </dt>
<dd>
<p>All <code>e&#8230;&#8203;</code> objects are forwarded and stored into the returned object of unspecified type, which should be captured by <code>auto</code> and kept alive in the calling scope. When that object is destroyed:</p>
<div class="ulist">
<ul>
<li>
<p>If <a href="#new_error"><code>new_error</code></a> was invoked (by the calling thread) since the object returned by <code>preload</code> was created, the stored <code>e&#8230;&#8203;</code> objects are <a href="#tutorial-loading">loaded</a> and become uniquely associated with <a href="#current_error"><code>current_error</code></a>;</p>
</li>
<li>
<p>Otherwise, if <code>std::unhandled_exception()</code> returns <code>true</code>, the stored <code>e&#8230;&#8203;</code> objects are loaded and become uniquely associated with the value returned by <a href="#new_error"><code>new_error</code></a>;</p>
</li>
<li>
<p>Otherwise, the stored <code>e&#8230;&#8203;</code> objects are discarded.</p>
</li>
</ul>
</div>
</dd>
</dl>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
See <a href="#tutorial-preload">Using <code>preload</code></a> from the Tutorial.
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect2">
<h3 id="remote_try_catch"><code>remote_try_catch</code></h3>
<div class="listingblock">
<div class="title">#include &lt;boost/leaf/handle_exception.hpp&gt;</div>
<div class="content">
<pre class="highlight nowrap"><code class="language-c++" data-lang="c++">namespace boost { namespace leaf {

  template &lt;class TryBlock, class RemoteH&gt;
  typename std::decay&lt;decltype(std::declval&lt;TryBlock&gt;()())&gt;::type
  remote_try_catch( TryBlock &amp;&amp; try_block, RemoteH &amp;&amp; h );

} }</code></pre>
</div>
</div>
<div class="paragraph">
<p>This function works similarly to <a href="#remote_try_handle_some"><code>remote_try_handle_some</code></a>, but handles exceptions rather than a <code>result&lt;T&gt;</code> result. Here is an example of how remote handlers should be captured so the captured function is compatible with  <code>remote_try_catch</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight nowrap"><code class="language-c++" data-lang="c++">auto remote_handlers = []( leaf::error_info const &amp; error )
{
  return leaf::remote_handle_exception( error,

    []( my_error_code ec, leaf::e_file_name const &amp; fn )
    {
      ....
    },

    []( my_error_code ec )
    {
      ....
    } );
};</code></pre>
</div>
</div>
<div class="paragraph text-right">
<p><a href="#error_info"><code>error_info</code></a> | <a href="#e_file_name"><code>e_file_name</code></a></p>
</div>
<div class="paragraph">
<p>To use the captured <code>remote_handlers</code>, we call <code>remote_try_catch</code> rather than <a href="#try_catch"><code>try_catch</code></a> (the latter requires the handlers to be passed inline):</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight nowrap"><code class="language-c++" data-lang="c++">return leaf::remote_try_catch(
  []
  {
    // Code which may throw
  },

  [&amp;]( leaf::error_info const &amp; error )
  {
    return remote_handlers(error);
  } );</code></pre>
</div>
</div>
<div class="paragraph text-right">
<p><a href="#error_info"><code>error_info</code></a></p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
See also <a href="#tutorial-remote_handlers">Working with Remote Handlers</a> from the Tutorial.
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect2">
<h3 id="remote_try_handle_all"><code>remote_try_handle_all</code></h3>
<div class="listingblock">
<div class="title">#include &lt;boost/leaf/handle_error.hpp&gt;</div>
<div class="content">
<pre class="highlight nowrap"><code class="language-c++" data-lang="c++">namespace boost { namespace leaf {

  template &lt;class TryBlock, class RemoteH&gt;
  typename std::decay&lt;decltype(std::declval&lt;TryBlock&gt;()().value())&gt;::type
  remote_try_handle_all( TryBlock &amp;&amp; try_block, RemoteH &amp;&amp; h );

} }</code></pre>
</div>
</div>
<div class="paragraph">
<p>This function works similarly to <a href="#remote_try_handle_some"><code>remote_try_handle_some</code></a>, but like other &#8220;_all&#8221; functions, it is required to handle any error (enforced at compile-time). Therefore, the captured <code>remote_handlers</code> must include a handler that matches any error:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight nowrap"><code class="language-c++" data-lang="c++">auto remote_handlers = []( leaf::error_info const &amp; error )
{
  return leaf::remote_handle_all( error,

    []( my_error_code ec, leaf::e_file_name const &amp; fn )
    {
      ....
    },

    []( my_error_code ec )
    {
      ....
    },

    [] //Matches any error
    {
      ....
    } );
};</code></pre>
</div>
</div>
<div class="paragraph text-right">
<p><a href="#error_info"><code>error_info</code></a> | <a href="#e_file_name"><code>e_file_name</code></a></p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
For the capture (above) to be compatible with <code>remote_try_handle_all</code>, it must use the helper function <code>remote_handle_all</code>.
</td>
</tr>
</table>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
See also <a href="#tutorial-remote_handlers">Working with Remote Handlers</a> from the Tutorial.
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect2">
<h3 id="remote_try_handle_some"><code>remote_try_handle_some</code></h3>
<div class="listingblock">
<div class="title">#include &lt;boost/leaf/handle_error.hpp&gt;</div>
<div class="content">
<pre class="highlight nowrap"><code class="language-c++" data-lang="c++">namespace boost { namespace leaf {

  template &lt;class TryBlock, class RemoteH&gt;
  typename std::decay&lt;decltype(std::declval&lt;TryBlock&gt;()())&gt;::type
  remote_try_handle_some( TryBlock &amp;&amp; try_block, RemoteH &amp;&amp; h );

} }</code></pre>
</div>
</div>
<div class="paragraph">
<p>This function works the same way as <a href="#try_handle_some"><code>try_handle_some</code></a> and has the same requirements, but rather than taking the handlers inline in a parameter pack, it takes a single function that captures the handlers, created like this:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight nowrap"><code class="language-c++" data-lang="c++">auto remote_handlers = []( leaf::error_info const &amp; error )
{
  return leaf::remote_handle_some( error,

    []( my_error_code ec, leaf::e_file_name const &amp; fn )
    {
      ....
    },

    []( my_error_code ec )
    {
      ....
    } );
};</code></pre>
</div>
</div>
<div class="paragraph text-right">
<p><a href="#error_info"><code>error_info</code></a> | <a href="#e_file_name"><code>e_file_name</code></a></p>
</div>
<div class="paragraph">
<p>Above, the <code>remote_handlers</code> function object captures the two handlers passed to the helper function <code>remote_handle_some</code>. Note that the function itself or the handlers are <strong>not</strong> called at this point; the only effect is that we now have a function, which we can later invoke to handle errors, using <code>remote_try_handle_some</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight nowrap"><code class="language-c++" data-lang="c++">return leaf::remote_try_handle_some(
  []
  {
    // Code which may fail
  },

  [&amp;]( leaf::error_info const &amp; error )
  {
    return remote_handlers(error);
  } );</code></pre>
</div>
</div>
<div class="paragraph text-right">
<p><a href="#error_info"><code>error_info</code></a></p>
</div>
<div class="paragraph">
<p>Like <a href="#try_handle_some"><code>try_handle_some</code></a>, the first thing <code>remote_try_handle_some</code> does is call the passed <code>try_block</code>. If it succeeds, the returned <code>result&lt;T&gt;</code> is forwarded to the caller. Otherwise, it calls <code>h</code> with the <code>leaf::error_info</code> object that represents the error being handled, where we call the <code>remote_handlers</code> function we captured earlier, which will attempt to find a matching handler, as usual.</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
<a href="#remote_try_handle_some"><code>remote_try_handle_some</code></a> catches and handles exceptions iff at least one of the supplied remote handlers takes an argument of type that is an instance of the <a href="#catch_"><code>catch_</code></a> template; otherwise it is exception-neutral.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Note that it is possible for <code>remote_handlers</code> to take additional arguments that it needs in order to handle errors:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight nowrap"><code class="language-c++" data-lang="c++">auto remote_handlers = []( leaf::error_info const &amp; error, int a )
{
  return leaf::remote_handle_some( error,

    [&amp;]( my_error_code ec, leaf::e_file_name const &amp; fn )
    {
      use(a);
      ....
    },

    []( my_error_code ec )
    {
      ....
    } );
};</code></pre>
</div>
</div>
<div class="paragraph text-right">
<p><a href="#error_info"><code>error_info</code></a> | <a href="#e_file_name"><code>e_file_name</code></a></p>
</div>
<div class="paragraph">
<p>Of course, later it is our responsibility to pass the extra arguments:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight nowrap"><code class="language-c++" data-lang="c++">return leaf::remote_try_handle_some(
  []
  {
    // Code which may fail
  },
  [&amp;]( leaf::error_info const &amp; error )
  {
    return remote_handlers(error, 42); // Pass 42 for a
  } );</code></pre>
</div>
</div>
<div class="paragraph text-right">
<p><a href="#error_info"><code>error_info</code></a></p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
See also <a href="#tutorial-remote_handlers">Working with Remote Handlers</a> from the Tutorial.
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect2">
<h3 id="try_catch"><code>try_catch</code></h3>
<div class="listingblock">
<div class="title">#include &lt;boost/leaf/handle_exception.hpp&gt;</div>
<div class="content">
<pre class="highlight nowrap"><code class="language-c++" data-lang="c++">namespace boost { namespace leaf {

  template &lt;class TryBlock, class... H&gt;
  typename std::decay&lt;decltype(std::declval&lt;TryBlock&gt;()())&gt;::type
  try_catch( TryBlock &amp;&amp; try_block, H &amp;&amp; ... h );

} }</code></pre>
</div>
</div>
<div class="paragraph">
<p>The <code>try_catch</code> function works similarly to <a href="#try_handle_some"><code>try_handle_some</code></a>, except that it does not use or understand the semantics of <code>result&lt;T&gt;</code> types; instead:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>It assumes that the <code>try_block</code> throws to indicate a failure, in which case <code>try_catch</code> will attempt to find a matching handler among <code>h&#8230;&#8203;</code>;</p>
</li>
<li>
<p>If a suitable handler isn&#8217;t found, the original exception is re-thrown using <code>throw;</code>.</p>
</li>
</ul>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
See also Five Minute Introduction <a href="#introduction-eh">Using Exception Handling</a>.
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect2">
<h3 id="try_handle_all"><code>try_handle_all</code></h3>
<div class="listingblock">
<div class="title">#include &lt;boost/leaf/handle_error.hpp&gt;</div>
<div class="content">
<pre class="highlight nowrap"><code class="language-c++" data-lang="c++">namespace boost { namespace leaf {

  template &lt;class TryBlock, class... H&gt;
  typename std::decay&lt;decltype(std::declval&lt;TryBlock&gt;()().value())&gt;::type
  try_handle_all( TryBlock &amp;&amp; try_block, H &amp;&amp; ... h );

} }</code></pre>
</div>
</div>
<div class="paragraph">
<p>The <code>try_handle_all</code> function works similarly to <a href="#try_handle_some"><code>try_handle_some</code></a>, except:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>In addition, it requires the passed handler pack to be able to handle any error, which is enforced at compile time, and</p>
</li>
<li>
<p>because it is required to handle all errors, <code>try_handle_all</code> unpacks the <code>result&lt;T&gt;</code> object <code>r</code> returned by the <code>try_block</code>, returning <code>r.value()</code> instead of <code>r</code>.</p>
</li>
</ul>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
See also Five Minute Introduction <a href="#introduction-result">Using <code>result&lt;T&gt;</code></a>.
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect2">
<h3 id="try_handle_some"><code>try_handle_some</code></h3>
<div class="listingblock">
<div class="title">#include &lt;boost/leaf/handle_error.hpp&gt;</div>
<div class="content">
<pre class="highlight nowrap"><code class="language-c++" data-lang="c++">namespace boost { namespace leaf {

  template &lt;class TryBlock, class... H&gt;
  typename std::decay&lt;decltype(std::declval&lt;TryBlock&gt;()())&gt;::type
  try_handle_some( TryBlock &amp;&amp; try_block, H &amp;&amp; ... h );

} }</code></pre>
</div>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">Requirements: </dt>
<dd>
<div class="ulist">
<ul>
<li>
<p>The <code>try_block</code> function may not take any arguments.</p>
</li>
<li>
<p>The type <code>R</code> returned by the <code>try_block</code> function must be a <code>result&lt;T&gt;</code> type (see <a href="#is_result_type"><code>is_result_type</code></a>). It is valid for the <code>try_block</code> to return <code>leaf::<a href="#result">result</a>&lt;T&gt;</code>, however this is not a requirement.</p>
</li>
<li>
<p>Each of the <code>h&#8230;&#8203;</code> functions:</p>
<div class="ulist">
<ul>
<li>
<p>may take arguments of <a href="#tutorial-is_e_type">E-types</a>, either by value or by <code>const &amp;</code>, or as a <code>const *</code>;</p>
</li>
<li>
<p>may take arguments, either by value or by <code>const &amp;</code>, of the predicate type <code><a href="#match">match</a>&lt;E, V&#8230;&#8203;&gt;</code>, where <code>E</code> is an E-type or an instance of the <a href="#condition"><code>condition</code></a> class template.</p>
</li>
<li>
<p>may take arguments, either by value or by <code>const &amp;</code>, of the predicate type <code><a href="#catch_">catch_</a>&lt;Ex&#8230;&#8203;&gt;</code>, where each of the <code>Ex</code> types derives from <code>std::exception</code> (in this case, please also <code>#include &lt;boost/leaf/handle_exception.hpp&gt;</code>);</p>
</li>
<li>
<p>may take an <a href="#error_info"><code>error_info</code></a> argument by <code>const &amp;</code>;</p>
</li>
<li>
<p>may take a <a href="#diagnostic_info"><code>diagnostic_info</code></a> argument by <code>const &amp;</code>;</p>
</li>
<li>
<p>may take a <a href="#verbose_diagnostic_info"><code>verbose_diagnostic_info</code></a> argument by <code>const &amp;</code>;</p>
</li>
<li>
<p>may not take any other types of arguments.</p>
</li>
<li>
<p>Must return a type that can be used to initialize an object of the type <code>R</code>; in case R is a <code>result&lt;void&gt;</code> (that is, in case of success it does not communicate a value), handlers that return <code>void</code> are permitted. If such a handler matches the failure, the <code>try_handle_some</code> return value is initialized by <code>{}</code>.</p>
</li>
</ul>
</div>
</li>
</ul>
</div>
</dd>
<dt class="hdlist1">Effects: </dt>
<dd>
<div class="ulist">
<ul>
<li>
<p>Creates a local <code><a href="#context">context</a>&lt;E&#8230;&#8203;&gt;</code> object <code>ctx</code>, where the <code>E&#8230;&#8203;</code> types are automatically deduced from the types of arguments taken by each <code>h&#8230;&#8203;</code>, which guarantees that it is able to store all of the types required to handle errors.</p>
</li>
<li>
<p>Invokes the <code>try_block</code>:</p>
<div class="ulist">
<ul>
<li>
<p>if the returned object <code>r</code> indicates success, it is forwarded to the caller.</p>
</li>
<li>
<p>otherwise, LEAF  considers each of the <code>h&#8230;&#8203;</code> handlers, in order, until it finds one that matches the reported <code>r.error()</code>. The first matching handler is invoked and its return value is used to initialize the return value of <code>try_handle_some</code>, which can indicate success if the handler was able to handle the error, or failure if it was not.</p>
</li>
<li>
<p>if <code>try_handle_some</code> is unable to find a matching handler, it returns <code>r</code>.</p>
</li>
</ul>
</div>
</li>
</ul>
</div>
</dd>
</dl>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<code>try_handle_some</code> is exception-neutral: it does not throw exceptions, however the user-supplied handlers are permitted to throw.
</td>
</tr>
</table>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">Handler Matching Procedure: </dt>
<dd>
<div class="paragraph">
<p>A handler <code>h</code> matches the failure reported by <code>r</code> iff <code>try_handle_some</code> is able to produce values to pass as its arguments, using the E-types stored in <code>ctx</code>, associated with the error ID obtained by calling <code>r.error()</code>. As soon as it is determined that an argument value can not be produced, the current handler is dropped and the matching procedure continues with the next handler, if any.</p>
</div>
<div class="paragraph">
<p>The return value of <code>r.error()</code> must be implicitly convertible to <a href="#error_id"><code>error_id</code></a>. Naturally, the <code>leaf::result</code> template satisfies this requirement. If an external <code>result</code> type is used instead, usually <code>r.error()</code> would return a <code>std::error_code</code>, which is able to communicate LEAF error IDs; see <a href="#tutorial-interoperability">Interoperability</a>.</p>
</div>
<div class="paragraph">
<p>If <code>err</code> is the error ID obtained from <code>r.error()</code>, each argument value <code>a</code><sub>i</sub> to be passed to the handler currently under consideration is produced as follows:</p>
</div>
<div class="openblock">
<div class="content">
<div class="ulist">
<ul>
<li>
<p>If <code>a</code><sub>i</sub> is taken as <code>A</code><sub>i</sub> <code>const &amp;</code> or by value:</p>
<div class="ulist">
<ul>
<li>
<p>If an E-object of type <code>A</code><sub>i</sub>, associated with <code>err</code>, is currently stored in <code>ctx</code>, <code>a</code><sub>i</sub> is initialized with a reference to the stored object; otherwise the handler is dropped.</p>
<div class="listingblock">
<div class="title">Example:</div>
<div class="content">
<pre class="highlight nowrap"><code class="language-c++" data-lang="c++">....
auto r = leaf::try_handle_some(
  []
  {
    return f(); // returns leaf::result&lt;int&gt;
  },

  []( leaf::e_file_name const &amp; fn ) <i class="conum" data-value="1"></i><b>(1)</b>
  {
    std::cerr &lt;&lt; "File Name: \"" &lt;&lt; fn.value &lt;&lt; '"' &lt;&lt; std::endl; <i class="conum" data-value="2"></i><b>(2)</b>
    return 1;
  } );</code></pre>
</div>
</div>
<div class="paragraph text-right">
<p><a href="#result"><code>result</code></a> | <a href="#e_file_name"><code>e_file_name</code></a></p>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>In case the <code>try_block</code> (the first lambda) indicates a failure, this handler will be matched if <code>ctx</code> stores an <code>e_file_name</code> associated with the error. Because this is the only supplied handler, if an <code>e_file_name</code> is not available, <code>try_handle_some</code> will return the <code>leaf::result&lt;int&gt;</code> returned by <code>f</code>.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>Print the file name, handle the error.</td>
</tr>
</table>
</div>
</li>
<li>
<p>If <code>A</code><sub>i</sub> is of the predicate type <code><a href="#match">match</a>&lt;E,V&#8230;&#8203;&gt;</code>, if an object of type <code>E</code>, associated with <code>err</code>, is currently stored in <code>ctx</code>, <code>a</code><sub>i</sub> is initialized with a reference to the stored object; otherwise the handler is dropped. The handler is also dropped if the expression <code>a</code><sub>i</sub><code>()</code> evaluates to <code>false</code> (see <code><a href="#match">match</a>&lt;E,V&#8230;&#8203;&gt;</code>).</p>
<div class="listingblock">
<div class="title">Example:</div>
<div class="content">
<pre class="highlight nowrap"><code class="language-c++" data-lang="c++">enum class errors
{
  ec1=1,
  ec2,
  ec3
};

....

try_handle_some(
  []
  {
    return f();
  },

  []( leaf::match&lt;errors, errors::ec1&gt; ) <i class="conum" data-value="1"></i><b>(1)</b>
  {
    ....
  },

  []( errors ec ) <i class="conum" data-value="2"></i><b>(2)</b>
  {
    ....
  } );
}</code></pre>
</div>
</div>
<div class="paragraph text-right">
<p><a href="#result"><code>result</code></a> | <a href="#match"><code>match</code></a></p>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>This handler is matched if the error includes an object of type <code>errors</code> with value <code>ec1</code>.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>This handler is matched if the error includes an object of type <code>errors</code> regardless of its value.</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>In particular, the <code>E</code> type used to instantiate the <code>match</code> template may be an instance of the <a href="#condition"><code>condition</code></a> class template, which is used to match a <code>std::error_condition</code> enumerated value:</p>
</div>
<div class="listingblock">
<div class="title">Example:</div>
<div class="content">
<pre class="highlight nowrap"><code class="language-c++" data-lang="c++">enum class cond_x { x00, x11, x22, x33 };

namespace std { template &lt;&gt; struct is_error_condition_enum&lt;cond_x&gt;: true_type { }; };

....

try_handle_some(
  []
  {
    return f();
  },

  [&amp;c]( leaf::match&lt;leaf::condition&lt;cond_x&gt;, cond_x::x11&gt; ) <i class="conum" data-value="1"></i><b>(1)</b>
  {
    ....
  },

  []( std::error_code const &amp; ec ) <i class="conum" data-value="2"></i><b>(2)</b>
  {
    ....
  } );
}</code></pre>
</div>
</div>
<div class="paragraph text-right">
<p><a href="#result"><code>result</code></a> | <a href="#match"><code>match</code></a> | <a href="#condition"><code>condition</code></a></p>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>This handler is matched if the error includes an object of type <code>std::error_code</code> equivalent to the error condition <code>cond_x::x11</code>.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>This handler is matched if the error includes any object of type <code>std::error_code</code>.</td>
</tr>
</table>
</div>
</li>
<li>
<p>If <code>A</code><sub>i</sub> is of the predicate type <code><a href="#catch_">catch_</a>&lt;Ex&#8230;&#8203;&gt;</code>, and the <code>try_block</code> throws, <code>a</code><sub>i</sub> is initialized with the current <code>std::exception</code>. The handler is dropped if the expression <code>a</code><sub>i</sub><code>()</code> evaluates to <code>false</code> (see <code><a href="#catch_">catch_</a>&lt;Ex&#8230;&#8203;&gt;</code>).</p>
<div class="listingblock">
<div class="title">Example:</div>
<div class="content">
<pre class="highlight nowrap"><code class="language-c++" data-lang="c++">struct exception1: std::exception { };
struct exception2: std::exception { };
struct exception3: std::exception { };

....

try_handle_some(
  []
  {
    return f(); // throws
  },

  []( leaf::catch_&lt;exception1, exception2&gt; ) <i class="conum" data-value="1"></i><b>(1)</b>
  {
    ....
  },

  []( leaf::error_info const &amp; info ) <i class="conum" data-value="2"></i><b>(2)</b>
  {
    ....
  } );</code></pre>
</div>
</div>
<div class="paragraph text-right">
<p><a href="#result"><code>result</code></a> | <a href="#catch_"><code>catch_</code></a> | <a href="#error_info"><code>error_info</code></a></p>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>This handler is matched if the current exception is either of type <code>exception1</code> or <code>exception2</code>.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>This handler is matched any error. Use <code>info.<a href="#error_info">exception</a>()</code> to access the caught <code>std::exception</code> object.</td>
</tr>
</table>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
Using <a href="#catch_"><code>catch_</code></a> requires <code>#include &lt;boost/leaf/handle_exception.hpp&gt;</code>.
</td>
</tr>
</table>
</div>
</li>
</ul>
</div>
</li>
<li>
<p>If <code>a</code><sub>i</sub> is of type <code>A</code><sub>i</sub> <code>const *</code>, <code>try_handle_some</code> is always able to produce it: first it attempts to match it as if it is taken by <code>const &amp;</code>; if that fails, <code>a</code><sub>i</sub> is initialized with <code>0</code>.</p>
<div class="listingblock">
<div class="title">Example:</div>
<div class="content">
<pre class="highlight nowrap"><code class="language-c++" data-lang="c++">....
try_handle_some(
  []
  {
    return f(); // throws
  },

  []( leaf::e_file_name const * fn ) -&gt; leaf::result&lt;void&gt; <i class="conum" data-value="1"></i><b>(1)</b>
  {
    if( fn ) <i class="conum" data-value="2"></i><b>(2)</b>
      std::cerr &lt;&lt; "File Name: \"" &lt;&lt; fn-&gt;value &lt;&lt; '"' &lt;&lt; std::endl;
  } );
}</code></pre>
</div>
</div>
<div class="paragraph text-right">
<p><a href="#result"><code>result</code></a> | <a href="#e_file_name"><code>e_file_name</code></a></p>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>This handler matches any error, because it takes <code>e_file_name</code> as a <code>const *</code> (and nothing by <code>const &amp;</code>).</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>If an <code>e_file_name</code> is available with the current error, print it.</td>
</tr>
</table>
</div>
</li>
<li>
<p>If <code>a</code><sub>i</sub> is of type <code>error_info const &amp;</code>,  <code>try_handle_some</code> is always able to produce it.</p>
<div class="listingblock">
<div class="title">Example:</div>
<div class="content">
<pre class="highlight nowrap"><code class="language-c++" data-lang="c++">....
try_handle_some(
  []
  {
    return f(); // returns leaf::result&lt;T&gt;
  },

  []( leaf::error_info const &amp; info ) <i class="conum" data-value="1"></i><b>(1)</b>
  {
    std::cerr &lt;&lt; "leaf::error_info:" &lt;&lt; std::endl &lt;&lt; info; <i class="conum" data-value="2"></i><b>(2)</b>
    return info.error(); <i class="conum" data-value="3"></i><b>(3)</b>
  } );</code></pre>
</div>
</div>
<div class="paragraph text-right">
<p><a href="#result"><code>result</code></a> | <a href="#error_info"><code>error_info</code></a></p>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>This handler matches any error.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>Print error information.</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>Return the original error, which will be returned out of <code>try_handle_some</code>.</td>
</tr>
</table>
</div>
</li>
<li>
<p>If <code>a</code><sub>i</sub> is of type <code>diagnostic_info const &amp;</code>,  <code>try_handle_some</code> is always able to produce it.</p>
<div class="listingblock">
<div class="title">Example:</div>
<div class="content">
<pre class="highlight nowrap"><code class="language-c++" data-lang="c++">....
try_handle_some(
  []
  {
    return f(); // throws
  },

  []( leaf::diagnostic_info const &amp; info ) <i class="conum" data-value="1"></i><b>(1)</b>
  {
    std::cerr &lt;&lt; "leaf::diagnostic_information:" &lt;&lt; std::endl &lt;&lt; info; <i class="conum" data-value="2"></i><b>(2)</b>
    return info.error(); <i class="conum" data-value="3"></i><b>(3)</b>
  } );</code></pre>
</div>
</div>
<div class="paragraph text-right">
<p><a href="#result"><code>result</code></a> | <a href="#diagnostic_info"><code>diagnostic_info</code></a></p>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>This handler matches any error.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>Print diagnostic information, including limited information about dropped error objects.</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>Return the original error, which will be returned out of <code>try_handle_some</code>.</td>
</tr>
</table>
</div>
</li>
<li>
<p>If <code>a</code><sub>i</sub> is of type <code>verbose_diagnostic_info const &amp;</code>,  <code>try_handle_some</code> is always able to produce it.</p>
<div class="listingblock">
<div class="title">Example:</div>
<div class="content">
<pre class="highlight nowrap"><code class="language-c++" data-lang="c++">....
try_handle_some(
  []
  {
    return f(); // throws
  },

  []( leaf::verbose_diagnostic_info const &amp; info ) <i class="conum" data-value="1"></i><b>(1)</b>
  {
    std::cerr &lt;&lt; "leaf::verbose_diagnostic_information:" &lt;&lt; std::endl &lt;&lt; info; <i class="conum" data-value="2"></i><b>(2)</b>
    return info.error(); <i class="conum" data-value="3"></i><b>(3)</b>
  } );</code></pre>
</div>
</div>
<div class="paragraph text-right">
<p><a href="#result"><code>result</code></a> | <a href="#verbose_diagnostic_info"><code>verbose_diagnostic_info</code></a></p>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>This handler matches any error.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>Print verbose diagnostic information, including values of dropped error objects.</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>Return the original error, which will be returned out of <code>try_handle_some</code>.</td>
</tr>
</table>
</div>
</li>
</ul>
</div>
</div>
</div>
</dd>
</dl>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="types">Reference: Types</h2>
<div class="sectionbody">
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
The contents of each Reference section are organized alphabetically.
</td>
</tr>
</table>
</div>
<hr>
<div class="sect2">
<h3 id="augment_id"><code>augment_id</code></h3>
<div class="listingblock">
<div class="content">
<pre class="highlight nowrap"><code class="language-c++" data-lang="c++">namespace boost { namespace leaf {

  class augment_id
  {
  public:

    augment_id() noexcept;

    error_id check_error() const noexcept;

    template &lt;class... E&gt;
    error_id get_error( E &amp;&amp; ... e ) const noexcept;
  };

} }</code></pre>
</div>
</div>
<div class="paragraph">
<p>This class helps obtain an <a href="#error_id"><code>error_id</code></a> to associate error objects with, when augmenting failures communicated using LEAF through uncooperative APIs that do not use LEAF to report errors.</p>
</div>
<div class="paragraph">
<p>The common usage of this class is as follows:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight nowrap"><code class="language-c++" data-lang="c++">error_code compute_value( int * out_value ) noexcept; <i class="conum" data-value="1"></i><b>(1)</b>

leaf::error&lt;int&gt; augmenter() noexcept
{
  leaf::augment_id augment; <i class="conum" data-value="2"></i><b>(2)</b>

  int val;
  auto ec = compute_value(&amp;val);

  if( failure(ec) )
    return augment.get_error(e1, e2, ...); <i class="conum" data-value="3"></i><b>(3)</b>
  else
    return val; <i class="conum" data-value="4"></i><b>(4)</b>
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Uncooperative third-party API that does not use LEAF, but results in calling a user callback that does use LEAF. In case our callback reports a failure, we&#8217;ll augment it with error objects available in the calling scope, even though <code>compute_value</code> can not communicate an <a href="#error_id"><code>error_id</code></a>.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>Initialize an <code>augment_id</code> object.</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>The call to <code>compute_value</code> has failed:
<div class="ulist">
<ul>
<li>
<p>If <a href="#new_error"><code>new_error</code></a> was invoked (by the calling thread) after the <code>augment</code> object was initialized, <code>get_error</code> returns the last <code>error_id</code> returned by <code>new_error</code>. This would be the case if the failure originates in our callback (invoked internally by <code>compute_value</code>).</p>
</li>
<li>
<p>Else, <code>get_error</code> invokes <code>new_error</code> and returns that <code>error_id</code>.</p>
</li>
</ul>
</div></td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i><b>4</b></td>
<td>The call was successful, return the computed value.</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>The <code>check_error</code> function works similarly, but instead of invoking <code>new_error</code> it returns a defaul-initialized <code>error_id</code>.</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
See <a href="#tutorial-preload_in_c_callbacks">Using <code>augment_id</code> in (Lua) C-callbacks</a>.
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect2">
<h3 id="catch_"><code>catch_</code></h3>
<div class="listingblock">
<div class="content">
<pre class="highlight nowrap"><code class="language-c++" data-lang="c++">namespace boost { namespace leaf {

  template &lt;class... Ex&gt;
  struct catch_
  {
    std::exception const &amp; value;

    explicit catch_( std::exception const &amp; ex ) noexcept;

    bool operator()() const noexcept;
  };

} }</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
The <code>catch_</code> template is useful only as an argument to a handler function passed to a LEAF error-handling function.
</td>
</tr>
</table>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">Effects: </dt>
<dd>
<p>The <code>catch_</code> constructor initializes the <code>value</code> reference with <code>ex</code>.</p>
</dd>
</dl>
</div>
<div class="paragraph">
<p>The <code>catch_</code> template is a predicate function type: <code>operator()</code> returns <code>true</code> iff for at least one of <code>Ex</code><sub>i</sub> in <code>Ex&#8230;&#8203;</code>, the expression <code>dynamic_cast&lt;Ex<sub>i</sub> const *&gt;(&amp;value) != 0</code> is <code>true</code>.</p>
</div>
<div class="listingblock">
<div class="title">Example:</div>
<div class="content">
<pre class="highlight nowrap"><code class="language-c++" data-lang="c++">struct exception1: std::exception { };
struct exception2: std::exception { };
struct exception3: std::exception { };

exception2 x;

catch_&lt;exception1&gt; c1(x);
assert(!c1());

catch_&lt;exception2&gt; c2(x);
assert(c2());

catch_&lt;exception1,exception2&gt; c3(x);
assert(c3());

catch_&lt;exception1,exception3&gt; c4(x);
assert(!c4());</code></pre>
</div>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
See Five Minute Introduction <a href="#introduction-eh">Using Exception Handling</a>.
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect2">
<h3 id="condition"><code>condition</code></h3>
<div class="listingblock">
<div class="content">
<pre class="highlight nowrap"><code class="language-c++" data-lang="c++">namespace boost { namespace leaf {

  template &lt;class Enum, class ErrorConditionEnum = Enum&gt;
  struct condition;

} }</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
The <code>condition</code> template is useful only as argument to the <a href="#match"><code>match</code></a> template, to match a specific <code>std::error_condition</code>.
</td>
</tr>
</table>
</div>
<div class="listingblock">
<div class="title">Example:</div>
<div class="content">
<pre class="highlight nowrap"><code class="language-c++" data-lang="c++">enum class cond_x { x00, x11, x22, x33 };

namespace std { template &lt;&gt; struct is_error_condition_enum&lt;cond_x&gt;: true_type { }; };

std::error_code ec;
match&lt;condition&lt;cond_x, cond_x::x11&gt;&gt; m(ec);

// m() evaluates to true if ec is equivalent to the error condition cond_x::x11.</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
See also <a href="#match"><code>match</code></a>.
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect2">
<h3 id="context"><code>context</code></h3>
<div class="listingblock">
<div class="title">#include &lt;boost/leaf/context.hpp&gt;</div>
<div class="content">
<pre class="highlight nowrap"><code class="language-c++" data-lang="c++">namespace boost { namespace leaf {

  template &lt;class... E&gt;
  class context
  {
    context( context const &amp; ) = delete;
    context &amp; operator=( context const &amp; ) = delete;

  public:

    context() noexcept;
    context( context &amp;&amp; x ) noexcept;
    ~context() noexcept;

    void activate() noexcept;
    void deactivate() noexcept;
    bool is_active() const noexcept = 0;

    void propagate() noexcept = 0;

    void print( std::ostream &amp; os ) const;

    template &lt;class R, class... H&gt;
    R handle_error( error_id, H &amp;&amp; ... ) const;

    template &lt;class R, class RemoteH&gt;
    R remote_handle_error( error_id, RemoteH &amp;&amp; ) const;

  };

  template &lt;class RemoteH&gt;
  using context_type_from_remote_handler = typename &lt;&lt;unspecified&gt;&gt;::type;

} }</code></pre>
</div>
</div>
<div class="paragraph text-right">
<p><a href="#context::context">Constructors</a> | <a href="#context::activate"><code>activate</code></a> | <a href="#context::deactivate"><code>deactivate</code></a> | <a href="#context::is_active"><code>is_active</code></a> | <a href="#context::print"><code>print</code></a> | <a href="#context::propagate"><code>propagate</code></a> | <a href="#context::handle_error"><code>handle_error</code></a> | <a href="#context::remote_handle_error"><code>remote_handle_error</code></a> | <a href="#context_type_from_remote_handler"><code>context_type_from_remote_handler</code></a></p>
</div>
<div class="paragraph">
<p>The <code>context</code> class template provides storage for each of the specified E-types. Typically, <code>context</code> objects are not used directly; they&#8217;re created internally when the <a href="#try_handle_some"><code>try_handle_some</code></a>, <a href="#try_handle_all"><code>try_handle_all</code></a> or <a href="#try_catch"><code>try_catch</code></a> functions are called, instantiated with E-types automatically deduced from the arguments of the passed handlers.</p>
</div>
<div class="paragraph">
<p>Independently, users can create <code>context</code> objects if they need to capture E-objects and then transport them, by moving the <code>context</code> object itself.</p>
</div>
<div class="paragraph">
<p>Even in that case it is recommended that users do not instantiate the <code>context</code> template by explicitly listing the E-types they want it to be able to store. Instead, use <a href="#context_type_from_remote_handler"><code>context_type_from_remote_handler</code></a> or call the <a href="#make_context"><code>make_context</code></a> function template, which deduce the correct E-types from a captured list of handler function objects.</p>
</div>
<div class="paragraph">
<p>To be able to load up error objects in a <code>context</code> object, it must be activated. Activating a <code>context</code> object <code>ctx</code> binds it to the calling thread, setting thread-local pointers of the stored <code>E&#8230;&#8203;</code> types to point to the corresponding storage within <code>ctx</code>. It is possible, even likely, to have more than one active <code>context</code> in any given thread. In this case, activation/deactivation must happen in a LIFO manner. For this reason, it is best to use a <a href="#context_activator"><code>context_activator</code></a>, which relies on RAII to activate and deactivate a <code>context</code>.</p>
</div>
<div class="paragraph">
<p>When a <code>context</code> is deactivated, it detaches from the calling thread, restoring the thread-local pointers to their pre-<code>activate</code> values. Typically, at this point the stored E-objects, if any, are either discarded (by default) or moved to corresponding storage in other <code>context</code> objects active in the calling thread (if available), by calling <a href="#context::propagate"><code>propagate</code></a>.</p>
</div>
<div class="paragraph">
<p>While error handling typically uses <a href="#try_handle_some"><code>try_handle_some</code></a>, <a href="#try_handle_all"><code>try_handle_all</code></a> or <a href="#try_catch"><code>try_catch</code></a>, it is also possible to handle errors by calling the member functions <a href="#context::handle_error"><code>handle_error</code></a> and <a href="#context::remote_handle_error"><code>remote_handle_error</code></a>. They take an <a href="#error_id"><code>error_id</code></a>, and attempt to match an error handler with E-objects stored in <code>*this</code>.</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
<code>context</code> objects can be moved, as long as they aren&#8217;t active. Moving an active <code>context</code> results in undefined behavior.
</td>
</tr>
</table>
</div>
<hr>
<div class="sect3">
<h4 id="context::context">Constructors</h4>
<div class="listingblock">
<div class="title">#include &lt;boost/leaf/context.hpp&gt;</div>
<div class="content">
<pre class="highlight nowrap"><code class="language-c++" data-lang="c++">namespace boost { namespace leaf {

  template &lt;class... E&gt;
  context&lt;E...&gt;::context() noexcept;

  template &lt;class... E&gt;
  context&lt;E...&gt;::context( context &amp;&amp; x ) noexcept;

} }</code></pre>
</div>
</div>
<div class="paragraph">
<p>The default constructor initializes an empty <code>context</code> object: it provides storage for, but does not contain any E-objects.</p>
</div>
<div class="paragraph">
<p>The move constructor moves the stored E-objects from one <code>context</code> to the other.</p>
</div>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<i class="fa icon-warning" title="Warning"></i>
</td>
<td class="content">
Moving an active <code>context</code> object results in undefined behavior.
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="context::activate"><code>activate</code></h4>
<div class="listingblock">
<div class="title">#include &lt;boost/leaf/context.hpp&gt;</div>
<div class="content">
<pre class="highlight nowrap"><code class="language-c++" data-lang="c++">namespace boost { namespace leaf {

  template &lt;class... E&gt;
  void context&lt;E...&gt;::activate() noexcept;

} }</code></pre>
</div>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">Preconditions: </dt>
<dd>
<p><code>!<a href="#context::is_active">is_active</a>()</code>.</p>
</dd>
<dt class="hdlist1">Effects: </dt>
<dd>
<p>Associates <code>*this</code> with the calling thread.</p>
</dd>
<dt class="hdlist1">Ensures: </dt>
<dd>
<p><code><a href="#context::is_active">is_active</a>()</code>.</p>
</dd>
</dl>
</div>
<div class="paragraph">
<p>When a context is associated with a thread, thread-local pointers are set to point each E-type in its store, while the previous value of each such pointer is preserved in the <code>context</code> object, so that the effect of <code>activate</code> can be undone by calling <code>deactivate</code>.</p>
</div>
<div class="paragraph">
<p>When an E-object is <a href="#tutorial-loading">loaded</a>, it is moved in the last activated (in the calling thread) <code>context</code> object that provides storage for that E-type (note that this may or may not be the last activated <code>context</code> object). If no such storage is available, the E-object is discarded.</p>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="context::deactivate"><code>deactivate</code></h4>
<div class="listingblock">
<div class="title">#include &lt;boost/leaf/context.hpp&gt;</div>
<div class="content">
<pre class="highlight nowrap"><code class="language-c++" data-lang="c++">namespace boost { namespace leaf {

  template &lt;class... E&gt;
  void context&lt;E...&gt;::deactivate() noexcept;

} }</code></pre>
</div>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">Preconditions: </dt>
<dd>
<div class="ulist">
<ul>
<li>
<p><code><a href="#context::is_active">is_active</a>()</code>;</p>
</li>
<li>
<p><code>*this</code> must be the last activated <code>context</code> object in the calling thread.</p>
</li>
</ul>
</div>
</dd>
<dt class="hdlist1">Effects: </dt>
<dd>
<p>De-associates <code>*this</code> with the calling thread.</p>
</dd>
<dt class="hdlist1">Ensures: </dt>
<dd>
<p><code>!<a href="#context::is_active">is_active</a>()</code>.</p>
</dd>
</dl>
</div>
<div class="paragraph">
<p>When a context is deactivated, the thread-local pointers that currently point to each individual E-object storage in it are restored to their original value prior to calling <a href="#context::activate"><code>activate</code></a>.</p>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="context::handle_error"><code>handle_error</code></h4>
<div class="listingblock">
<div class="title">#include &lt;boost/leaf/handle_error.hpp&gt;</div>
<div class="content">
<pre class="highlight nowrap"><code class="language-c++" data-lang="c++">namespace boost { namespace leaf {

  template &lt;class... E&gt;
  template &lt;class R, class... H&gt;
  R context&lt;E...&gt;::handle_error( error_id err, H &amp;&amp; ... h ) const;

} }</code></pre>
</div>
</div>
<div class="paragraph">
<p>This function works similarly to <a href="#try_handle_all"><code>try_handle_all</code></a>, but rather than calling a <code>try_block</code> and obtaining the <a href="#error_id"><code>error_id</code></a> from the returned <code>result</code> type, it matches error objects (stored in <code>*this</code>, associated with <code>err</code>) with a suitable error handler from the <code>h&#8230;&#8203;</code> pack.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
The caller is required to specify the return type <code>R</code>. This is because in general the supplied handlers may return different types (which must all be convertible to <code>R</code>).
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="context::is_active"><code>is_active</code></h4>
<div class="listingblock">
<div class="title">#include &lt;boost/leaf/context.hpp&gt;</div>
<div class="content">
<pre class="highlight nowrap"><code class="language-c++" data-lang="c++">namespace boost { namespace leaf {

  template &lt;class... E&gt;
  bool context&lt;E...&gt;::is_active() const noexcept;

} }</code></pre>
</div>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">Returns: </dt>
<dd>
<p><code>true</code> if the <code>*this</code> is active in any thread, <code>false</code> otherwise.</p>
</dd>
</dl>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="context::print"><code>print</code></h4>
<div class="listingblock">
<div class="title">#include &lt;boost/leaf/context.hpp&gt;</div>
<div class="content">
<pre class="highlight nowrap"><code class="language-c++" data-lang="c++">namespace boost { namespace leaf {

  template &lt;class... E&gt;
  void context&lt;E...&gt;::print( std::ostream &amp; os ) const;

} }</code></pre>
</div>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">Effects: </dt>
<dd>
<p>Prints all E-objects currently stored in <code>*this</code>, together with the unique error ID each individual E-object is associated with.</p>
</dd>
</dl>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="context::propagate"><code>propagate</code></h4>
<div class="listingblock">
<div class="title">#include &lt;boost/leaf/context.hpp&gt;</div>
<div class="content">
<pre class="highlight nowrap"><code class="language-c++" data-lang="c++">namespace boost { namespace leaf {

  template &lt;class... E&gt;
  void context&lt;E...&gt;::propagate() noexcept;

} }</code></pre>
</div>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">Preconditions: </dt>
<dd>
<p><code><a href="#context::is_active">is_active</a>()</code> or <code>*this</code> must be the last deactivated <code>context</code> object in the calling thread. That is, it is valid to call <code>propagate</code> while <code>is_active()</code> is <code>true</code>, or immediately after calling <code><a href="#context::deactivate">deactivate</a>()</code>.</p>
</dd>
<dt class="hdlist1">Effects: </dt>
<dd>
<p>Each stored E-object is moved to the storage (within other active <code>context</code> objects) pointed by the corresponding thread-local pointer, captured when <code>*this</code> was activated&#8201;&#8212;&#8201;or discarded, if the corresponding thread-local pointer is null.</p>
</dd>
</dl>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="context::remote_handle_error"><code>remote_handle_error</code></h4>
<div class="listingblock">
<div class="title">#include &lt;boost/leaf/handle_error.hpp&gt;</div>
<div class="content">
<pre class="highlight nowrap"><code class="language-c++" data-lang="c++">namespace boost { namespace leaf {

  template &lt;class... E&gt;
  template &lt;class R, class RemoteH&gt;
  R context&lt;E...&gt;::remote_handle_error( R &amp;, RemoteH &amp;&amp; ) const;

} }</code></pre>
</div>
</div>
<div class="paragraph">
<p>This function works similarly to <a href="#remote_try_handle_all"><code>remote_try_handle_all</code></a>, but rather than calling a <code>try_block</code> and obtaining the <a href="#error_id"><code>error_id</code></a> from the returned <code>result</code> type, it matches error objects (stored in <code>*this</code>, associated with <code>err</code>) with a suitable error handler from the <code>h&#8230;&#8203;</code> pack.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
The caller is required to specify the return type <code>R</code>. This is because in general the supplied handlers may return different types (which must all be convertible to <code>R</code>).
</td>
</tr>
</table>
</div>
<hr>
</div>
</div>
<div class="sect2">
<h3 id="context_activator"><code>context_activator</code></h3>
<div class="listingblock">
<div class="title">#include &lt;boost/leaf/error.hpp&gt;</div>
<div class="content">
<pre class="highlight nowrap"><code class="language-c++" data-lang="c++">namespace boost { namespace leaf {

  template &lt;class Ctx&gt;
  class context_activator
  {
    context_activator( context_activator const &amp; ) = delete;
    context_activator &amp; operator=( context_activator const &amp; ) = delete;

  public:

    explicit context_activator( Ctx &amp; ctx ) noexcept;
    context_activator( context_activator &amp;&amp; ) noexcept;
    ~context_activator() noexcept;
  };

} }</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>context_activator</code> is a simple class that activates and deactivates a <a href="#context"><code>context</code></a> using RAII:</p>
</div>
<div class="paragraph">
<p>If <code><a href="#context::is_active">ctx.is_active</a></code>() is <code>true</code> at the time the <code>context_activator</code> is initialized, the constructor and the destructor have no effects. Otherwise:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>The constructor stores a reference to <code>ctx</code> in <code>*this</code> and calls <code><a href="#context::activate">ctx.activate</a></code>().</p>
</li>
<li>
<p>The destructor:</p>
<div class="ulist">
<ul>
<li>
<p>Has no effects if <code>ctx.is_active()</code> is <code>false</code> (that is, it is valid to call <a href="#context::deactivate"><code>deactivate</code></a> manually, before the <code>context_activator</code> object expires);</p>
</li>
<li>
<p>Otherwise, calls <code><a href="#context::deactivate">ctx.deactivate</a></code>() and, if there are new uncaught exceptions since the constructor was called, the destructor calls <code><a href="#context::propagate">ctx.propagate</a></code>().</p>
</li>
</ul>
</div>
</li>
</ul>
</div>
<div class="paragraph">
<p>For automatic deduction of <code>Ctx</code>, use <a href="#activate_context"><code>activate_context</code></a>.</p>
</div>
<hr>
</div>
<div class="sect2">
<h3 id="diagnostic_info"><code>diagnostic_info</code></h3>
<div class="listingblock">
<div class="content">
<pre class="highlight nowrap"><code class="language-c++" data-lang="c++">namespace boost { namespace leaf {

  class diagnostic_info: public error_info
  {
    //Constructors unspecified

    friend std::ostream &amp; operator&lt;&lt;( std::ostream &amp; os, diagnostic_info const &amp; x );
  };

} }</code></pre>
</div>
</div>
<div class="paragraph">
<p>Handlers passed to <a href="#try_handle_some"><code>try_handle_some</code></a>, <a href="#try_handle_all"><code>try_handle_all</code></a> or <a href="#try_catch"><code>try_catch</code></a> may take an argument of type <code>diagnostic_info const &amp;</code> if they need to print diagnostic information about the error.</p>
</div>
<div class="paragraph">
<p>The message printed by <code>operator&lt;&lt;</code> includes the message printed by <code>error_info</code>, followed by basic information about E-objects that were communicated to LEAF (to be associated with the error) for which there was no storage available in any active <a href="#context"><code>context</code></a> (these E-objects were discarded by LEAF, because no handler needed them).</p>
</div>
<div class="paragraph">
<p>The additional information is limited to the type name of the first such E-object, as well as their total count.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>The behavior of <code>diagnostic_info</code> (and <a href="#verbose_diagnostic_info"><code>verbose_diagnostic_info</code></a>) is affected by the value of the macro <code>LEAF_DIAGNOSTICS</code>:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>If it is 1 (the default), LEAF produces <code>diagnostic_info</code> but only if an active error handling context on the call stack takes an argument of type <code>diagnostic_info</code>;</p>
</li>
<li>
<p>If it is 0, the <code>diagnostic_info</code> functionality is stubbed out even for error handling contexts that take an argument of type <code>diagnostic_info</code>. This could shave a few cycles off the error path in some programs.</p>
</li>
</ul>
</div>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect2">
<h3 id="error_id"><code>error_id</code></h3>
<div class="listingblock">
<div class="title">#include &lt;boost/leaf/error.hpp&gt;</div>
<div class="content">
<pre class="highlight nowrap"><code class="language-c++" data-lang="c++">namespace boost { namespace leaf {

  class error_id
  {
  public:

    error_id() noexcept;

    error_id( std::error_code const &amp; ec ) noexcept;

    int value() const noexcept;
    explicit operator bool() const noexcept;

    std::error_code to_error_code() const noexcept;

    friend bool operator==( error_id a, error_id b ) noexcept;
    friend bool operator!=( error_id a, error_id b ) noexcept;
    friend bool operator&lt;( error_id a, error_id b ) noexcept;

    template &lt;class... E&gt;
    error_id load( E &amp;&amp; ... e ) const noexcept;

    template &lt;class... F&gt;
    error_id accumulate( F &amp;&amp; ... f ) const noexcept;

    friend std::ostream &amp; operator&lt;&lt;( std::ostream &amp; os, error_id x );
  };

  bool is_error_id( std::error_code const &amp; ec ) noexcept;

  template &lt;class... E&gt;
  error_id new_error( E &amp;&amp; ... e ) noexcept;

  error_id current_error() noexcept;

} }</code></pre>
</div>
</div>
<div class="paragraph text-right">
<p><a href="#error_id::error_id">Constructors</a> | <a href="#error_id::value"><code>value</code></a> | <a href="#error_id::operator_bool"><code>operator bool</code></a> | <a href="#error_id::to_error_code"><code>to_error_code</code></a> | <a href="#error_id::comparison_operators"><code>operator==</code>, <code>!=</code>, <code>&lt;</code></a> | <a href="#error_id::load"><code>load</code></a> | <a href="#error_id::accumulate"><code>accumulate</code></a> | <a href="#is_error_id"><code>is_error_id</code></a> | <a href="#new_error"><code>new_error</code></a> | <a href="#current_error"><code>current_error</code></a></p>
</div>
<div class="paragraph">
<p>Values of type <code>error_id</code> identify a specific occurrence of an error condition across the entire program. They can be copied, moved, assigned to, and compared to other <code>error_id</code> objects. They&#8217;re as efficient as an <code>int</code>.</p>
</div>
<hr>
<div class="sect3">
<h4 id="error_id::error_id">Constructors</h4>
<div class="listingblock">
<div class="title">#include &lt;boost/leaf/error.hpp&gt;</div>
<div class="content">
<pre class="highlight nowrap"><code class="language-c++" data-lang="c++">namespace boost { namespace leaf {

  error_id::error_id() noexcept = default;

  error_id::error_id( std::error_code const &amp; ec ) noexcept;

} }</code></pre>
</div>
</div>
<div class="paragraph">
<p>A default-initialized <code>error_id</code> object does not represent an error condition. It compares equal to any other default-initialized <code>error_id</code> object. All other <code>error_id</code> objects identify a specific occurrence of a failure.</p>
</div>
<div class="paragraph">
<p>Converting an <code>error_id</code> object to <code>std::error_code</code> uses an unspecified <code>std::error_category</code> which LEAF recognizes. This allows an <code>error_id</code> to be transported through interfaces that work with <code>std::error_code</code>. There is an <code>error_id</code> constructor that allows the original <code>error_id</code> to be restored.</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
To check if a given <code>std::error_code</code> is actually carrying an <code>error_id</code>, use <a href="#is_error_id"><code>is_error_id</code></a>.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Typically, users create new <code>error_id</code> objects by invoking <a href="#new_error"><code>new_error</code></a>. The constructor that takes <code>std::error_code</code> has the following effects:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>If <code>ec.value()</code> is <code>0</code>, the effect is the same as using the default constructor.</p>
</li>
<li>
<p>Otherwise, if <code><a href="#is_error_id">is_error_id</a>(ec)</code> is <code>true</code>, the original <code>error_id</code> value is used to initialize <code>*this</code>;</p>
</li>
<li>
<p>Otherwise, <code>*this</code> is initialized by the value returned by <a href="#new_error"><code>new_error</code></a>, while <code>ec</code> is passed to <code>load</code>, enclosed in an unspecified E-type, which enables handlers used with <code>try_handle_some</code>, <code>try_handle_all</code> or <code>try_catch</code> to receive it as an argument of type <code>std::error_code</code> (or <code><a href="#match">match</a>&lt;<a href="#condition">condition</a>&gt;</code>).</p>
</li>
</ul>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="error_id::accumulate"><code>accumulate</code></h4>
<div class="listingblock">
<div class="title">#include &lt;boost/leaf/error.hpp&gt;</div>
<div class="content">
<pre class="highlight nowrap"><code class="language-c++" data-lang="c++">namespace boost { namespace leaf {

  template &lt;class... F&gt;
  error_id error_id::accumulate( F &amp;&amp; ... f ) const noexcept;

} }</code></pre>
</div>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">Requirements: </dt>
<dd>
<p>Each <code>f</code> must be a function type that takes a single E-type argument by l-value reference.</p>
</dd>
<dt class="hdlist1">Effects: </dt>
<dd>
<p>Similar to <a href="#error_id::load"><code>load</code></a>, but rather than <a href="#tutorial-loading">loading</a> E-types, it calls each <code>f<sub>i</sub></code> with the matching E-type object currently stored in an active <a href="#context"><code>context</code></a>; see <a href="#tutorial-accumulation">Accumulation</a>.</p>
</dd>
<dt class="hdlist1">Returns: </dt>
<dd>
<p><code>*this</code>.</p>
</dd>
</dl>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="is_error_id"><code>is_error_id</code></h4>
<div class="listingblock">
<div class="title">#include &lt;boost/leaf/error.hpp&gt;</div>
<div class="content">
<pre class="highlight nowrap"><code class="language-c++" data-lang="c++">namespace boost { namespace leaf {

  bool is_error_id( std::error_code const &amp; ec ) noexcept;

} }</code></pre>
</div>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">Returns: </dt>
<dd>
<p><code>true</code> if <code>ec</code> uses the LEAF-specific <code>std::error_category</code> that identifies it as carrying an error ID rather than another error code; otherwise returns <code>false</code>.</p>
</dd>
</dl>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="error_id::load"><code>load</code></h4>
<div class="listingblock">
<div class="title">#include &lt;boost/leaf/error.hpp&gt;</div>
<div class="content">
<pre class="highlight nowrap"><code class="language-c++" data-lang="c++">namespace boost { namespace leaf {

  template &lt;class... E&gt;
  error_id error_id::load( E &amp;&amp; ... e ) const noexcept;

} }</code></pre>
</div>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">Effects: </dt>
<dd>
<div class="ulist">
<ul>
<li>
<p>If <code>value()!=0</code>, each of the <code>e&#8230;&#8203;</code> objects is <a href="#tutorial-loading">loaded</a> and uniquely associated with <code>*this</code>.</p>
</li>
<li>
<p>Otherwise all <code>e&#8230;&#8203;</code> objects are discarded.</p>
</li>
</ul>
</div>
</dd>
<dt class="hdlist1">Returns: </dt>
<dd>
<p><code>*this</code>.</p>
</dd>
</dl>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="error_id::comparison_operators"><code>operator==</code>, <code>!=</code>, <code>&lt;</code></h4>
<div class="listingblock">
<div class="title">#include &lt;boost/leaf/error.hpp&gt;</div>
<div class="content">
<pre class="highlight nowrap"><code class="language-c++" data-lang="c++">namespace boost { namespace leaf {

  friend bool operator==( error_id a, error_id b ) noexcept;
  friend bool operator!=( error_id a, error_id b ) noexcept;
  friend bool operator&lt;( error_id a, error_id b ) noexcept;

} }</code></pre>
</div>
</div>
<div class="paragraph">
<p>These functions have the usual semantics, comparing <code>a.value()</code> and <code>b.value()</code>.</p>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="error_id::operator_bool"><code>operator bool</code></h4>
<div class="listingblock">
<div class="title">#include &lt;boost/leaf/error.hpp&gt;</div>
<div class="content">
<pre class="highlight nowrap"><code class="language-c++" data-lang="c++">namespace boost { namespace leaf {

    explicit error_id::operator bool() const noexcept;

} }</code></pre>
</div>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">Effects: </dt>
<dd>
<p>As if <code>return value()!=0</code>.</p>
</dd>
</dl>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="error_id::to_error_code"><code>to_error_code</code></h4>
<div class="listingblock">
<div class="title">#include &lt;boost/leaf/error.hpp&gt;</div>
<div class="content">
<pre class="highlight nowrap"><code class="language-c++" data-lang="c++">namespace boost { namespace leaf {

    std::error_code error_id::to_error_code() const noexcept;

} }</code></pre>
</div>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">Effects: </dt>
<dd>
<p>Returns a <code>std::error_object</code> with the same <code>value()</code> as <code>*this</code>, using an unspecified <code>std::error_category</code>.</p>
</dd>
</dl>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
The returned object can be used to initialize an <code>error_id</code>, in which case the original <code>error_id</code> value will be restored.
</td>
</tr>
</table>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
Use <a href="#is_error_id"><code>is_error_id</code></a> to check if a given <code>std::error_code</code> carries an <code>error_id</code>.
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="error_id::value"><code>value</code></h4>
<div class="listingblock">
<div class="title">#include &lt;boost/leaf/error.hpp&gt;</div>
<div class="content">
<pre class="highlight nowrap"><code class="language-c++" data-lang="c++">namespace boost { namespace leaf {

    int error_id::value() const noexcept;

} }</code></pre>
</div>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">Effects: </dt>
<dd>
<div class="ulist">
<ul>
<li>
<p>If <code>*this</code> was initialized using the default constructor, returns 0.</p>
</li>
<li>
<p>Otherwise returns an <code>int</code>, a program-wide unique identifier of the failure.</p>
</li>
</ul>
</div>
</dd>
</dl>
</div>
<hr>
</div>
</div>
<div class="sect2">
<h3 id="e_api_function"><code>e_api_function</code></h3>
<div class="listingblock">
<div class="content">
<pre class="highlight nowrap"><code class="language-c++" data-lang="c++">namespace boost { namespace leaf {

  struct e_api_function {char const * value;};

} }</code></pre>
</div>
</div>
<div class="paragraph">
<p>The <code>e_api_function</code> type is designed to capture the name of the API function that failed. For example, if you&#8217;re reporting an error from <code>fread</code>, you could use <code>leaf::e_api_function {"fread"}</code>.</p>
</div>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<i class="fa icon-warning" title="Warning"></i>
</td>
<td class="content">
The passed value is stored as a C string (<code>char const *</code>), so <code>value</code> should only be initialized with a string literal.
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect2">
<h3 id="e_at_line"><code>e_at_line</code></h3>
<div class="listingblock">
<div class="content">
<pre class="highlight nowrap"><code class="language-c++" data-lang="c++">namespace boost { namespace leaf {

  struct e_at_line { int value; };

} }</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>e_at_line</code> can be used to communicate the line number when reporting errors (for example parse errors) about a text file.</p>
</div>
<hr>
</div>
<div class="sect2">
<h3 id="e_errno"><code>e_errno</code></h3>
<div class="listingblock">
<div class="content">
<pre class="highlight nowrap"><code class="language-c++" data-lang="c++">namespace boost { namespace leaf {

  struct e_errno
  {
    int value;
    friend std::ostream &amp; operator&lt;&lt;( std::ostream &amp; os, e_errno const &amp; err );
  };

} }</code></pre>
</div>
</div>
<div class="paragraph">
<p>To capture <code>errno</code>, use <code>e_errno</code>. When printed in automatically-generated diagnostic messages, <code>e_errno</code> objects use <code>strerror</code> to convert the <code>errno</code> code to string.</p>
</div>
<hr>
</div>
<div class="sect2">
<h3 id="e_file_name"><code>e_file_name</code></h3>
<div class="listingblock">
<div class="content">
<pre class="highlight nowrap"><code class="language-c++" data-lang="c++">namespace boost { namespace leaf {

  struct e_file_name {std::string value;};

} }</code></pre>
</div>
</div>
<div class="paragraph">
<p>When a file operation fails, you could use <code>e_file_name</code> to store the name of the file.</p>
</div>
<hr>
</div>
<div class="sect2">
<h3 id="e_LastError"><code>e_LastError</code></h3>
<div class="listingblock">
<div class="content">
<pre class="highlight nowrap"><code class="language-c++" data-lang="c++">namespace boost { namespace leaf {

  namespace windows
  {
    struct e_LastError
    {
      unsigned value;
      friend std::ostream &amp; operator&lt;&lt;( std::ostream &amp; os, e_LastError const &amp; err );
    };
  }

} }</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>e_LastError</code> is designed to communicate <code>GetLastError()</code> values on Windows.</p>
</div>
<hr>
</div>
<div class="sect2">
<h3 id="e_source_location"><code>e_source_location</code></h3>
<div class="listingblock">
<div class="content">
<pre class="highlight nowrap"><code class="language-c++" data-lang="c++">namespace boost { namespace leaf {

  struct e_source_location
  {
    char const * const file;
    int const line;
    char const * const function;

    friend std::ostream &amp; operator&lt;&lt;( std::ostream &amp; os, e_source_location const &amp; x );
  };

} }</code></pre>
</div>
</div>
<div class="paragraph">
<p>The <a href="#LEAF_NEW_ERROR"><code>LEAF_NEW_ERROR</code></a>, <a href="#LEAF_EXCEPTION"><code>LEAF_EXCEPTION</code></a> and <a href="#LEAF_THROW"><code>LEAF_THROW</code></a> macros capture <code>__FILE__</code>, <code>__LINE__</code> and <code>__FUNCTION__</code> into a <code>e_source_location</code> object.</p>
</div>
<hr>
</div>
<div class="sect2">
<h3 id="e_type_info_name"><code>e_type_info_name</code></h3>
<div class="listingblock">
<div class="content">
<pre class="highlight nowrap"><code class="language-c++" data-lang="c++">namespace boost { namespace leaf {

  struct e_type_info_name { char const * value; };

} }</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>e_type_info_name</code> is designed to store the return value of <code>std::type_info::name</code>.</p>
</div>
<hr>
</div>
<div class="sect2">
<h3 id="error_info"><code>error_info</code></h3>
<div class="listingblock">
<div class="content">
<pre class="highlight nowrap"><code class="language-c++" data-lang="c++">namespace boost { namespace leaf {

  class error_info
  {
    //Constructors unspecified

  public:

    error_id error() const noexcept;

    bool exception_caught() const noexcept;
    std::exception const * exception() const noexcept;

    friend std::ostream &amp; operator&lt;&lt;( std::ostream &amp; os, error_info const &amp; x );
  };

} }</code></pre>
</div>
</div>
<div class="paragraph">
<p>Handlers passed to error-handling functions such as <a href="#try_handle_some"><code>try_handle_some</code></a>, <a href="#try_handle_all"><code>try_handle_all</code></a> or <a href="#try_catch"><code>try_catch</code></a> may take an argument of type <code>error_info const &amp;</code> to receive information about the error.</p>
</div>
<div class="paragraph">
<p>The <code>error</code> member function returns the program-wide unique <a href="#error_id"><code>error_id</code></a> of the error.</p>
</div>
<div class="paragraph">
<p>The <code>exception_caught</code> member function returns <code>true</code> if the handler that received <code>*this</code> is being invoked to handle an exception, <code>false</code> otherwise.</p>
</div>
<div class="paragraph">
<p>If handling an exception, the <code>exception</code> member function returns a pointer to the <code>std::exception</code> subobject of the caught exception, or <code>0</code> if that exception could not be converted to <code>std::exception</code>. It is illegal to call <code>exception</code> unless <code>exception_caught()</code> is <code>true</code>.</p>
</div>
<div class="paragraph">
<p>The <code>operator&lt;&lt;</code> overload prints diagnostic information about each E-object currently stored in the <a href="#context"><code>context</code></a> local to the <a href="#try_handle_some"><code>try_handle_some</code></a>, <a href="#try_handle_all"><code>try_handle_all</code></a> or <a href="#try_catch"><code>try_catch</code></a> scope that invoked the handler, but only if it is associated with the <a href="#error_id"><code>error_id</code></a> returned by <code>error()</code>.</p>
</div>
<hr>
</div>
<div class="sect2">
<h3 id="match"><code>match</code></h3>
<div class="listingblock">
<div class="content">
<pre class="highlight nowrap"><code class="language-c++" data-lang="c++">namespace boost { namespace leaf {

  template &lt;class E, typename deduced-type&lt;E&gt;::type... V&gt;
  class match
  {
  public:

    using type = typename unspecified-deduction&lt;E&gt;::type;

    explicit match( type const * value ) noexcept;

    explicit bool operator()() const noexcept;

    type const &amp; value() const noexcept;
  };

} }</code></pre>
</div>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">Effects: </dt>
<dd>
<div class="ulist">
<ul>
<li>
<p>If <code>E</code> is an instance of the <a href="#condition"><code>condition</code></a> template:</p>
<div class="ulist">
<ul>
<li>
<p>The type of the parameter pack <code>V&#8230;&#8203;</code> is deduced as the type of the error condition enum used with <code>condition</code>;</p>
</li>
<li>
<p><code>match&lt;E&gt;::type</code> is deduced as <code>std::error_code</code>;</p>
</li>
<li>
<p>The boolean conversion operator evaluates to <code>true</code> iff the <code>std::error_code</code> pointer passed to the constructor is not <code>0</code> and matches one of the error condition enum values used with <code>condition</code>.</p>
</li>
</ul>
</div>
</li>
<li>
<p>Otherwise, if <code>E</code> defines an accessible data member <code>value</code>:</p>
<div class="ulist">
<ul>
<li>
<p>The type of the parameter pack <code>V&#8230;&#8203;</code> and <code>match&lt;E&gt;::type</code> are deduced as <code>decltype(std::declval&lt;E&gt;().value)</code>;</p>
</li>
<li>
<p>The boolean conversion operator evaluates to <code>true</code> iff the <code>value</code> passed to the constructor is not <code>0</code> and is equal to one of <code>V&#8230;&#8203;</code>.</p>
</li>
</ul>
</div>
</li>
<li>
<p>Otherwise:</p>
<div class="ulist">
<ul>
<li>
<p>The type of the parameter pack <code>V&#8230;&#8203;</code> and <code>match&lt;E&gt;::type</code> are deduced as <code>E</code>;</p>
</li>
<li>
<p>The boolean conversion operator evaluates to <code>true</code> iff the <code>value</code> passed to the constructor is not <code>0</code> and is equal to one of <code>V&#8230;&#8203;</code>.</p>
</li>
</ul>
</div>
</li>
</ul>
</div>
</dd>
</dl>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
The examples below demonstrate how <code>match</code> works in isolation, but it is designed to be used as argument to a handler function passed to an error-handling function such as <a href="#try_handle_some"><code>try_handle_some</code></a>, <a href="#try_handle_all"><code>try_handle_all</code></a>, <a href="#try_catch"><code>try_catch</code></a>. See Five Minute Introduction <a href="#introduction-result">Using <code>result&lt;T&gt;</code></a> for a more practical example.
</td>
</tr>
</table>
</div>
<div class="listingblock">
<div class="title">Example 1:</div>
<div class="content">
<pre class="highlight nowrap"><code class="language-c++" data-lang="c++">struct error_code { int value; };

error_code e = {42};

match&lt;error_code, 1&gt; m1(e);
assert(!m1());

match&lt;error_code, 42&gt; m2(e);
assert(m2());

match&lt;error_code, 1, 5, 42, 7&gt; m3(e);
assert(m3());

match&lt;error_code, 1, 3, -42&gt; m4(e);
assert(!m4());</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">Example 2:</div>
<div class="content">
<pre class="highlight nowrap"><code class="language-c++" data-lang="c++">enum error_code { e1=1, e2, e3 };

error_code e = e2;

match&lt;error_code, e1&gt; m1(e);
assert(!m1());

match&lt;error_code, e2&gt; m2(e);
assert(m2());

match&lt;error_code, e1, e2&gt; m3(e);
assert(m3());

match&lt;error_code, e1, e3&gt; m4(e);
assert(!m4());</code></pre>
</div>
</div>
<hr>
</div>
<div class="sect2">
<h3 id="polymorphic_context"><code>polymorphic_context</code></h3>
<div class="listingblock">
<div class="title">#include &lt;boost/leaf/context.hpp&gt;</div>
<div class="content">
<pre class="highlight nowrap"><code class="language-c++" data-lang="c++">namespace boost { namespace leaf {

  class polymorphic_context
  {
  protected:

    polymorphic_context() noexcept;
    ~polymorphic_context() noexcept;

  public:

    virtual void activate() noexcept = 0;
    virtual void deactivate() noexcept = 0;
    virtual bool is_active() const noexcept = 0;

    virtual void propagate() noexcept = 0;

    virtual void print( std::ostream &amp; ) const = 0;
  };

} }</code></pre>
</div>
</div>
<div class="paragraph">
<p>The <code>polymorphic_context</code> class is an abstract base type which can be used to erase the type of the exact instantiation of the <a href="#context"><code>context</code></a> class template used. See <a href="#make_shared_context"><code>make_shared_context</code></a>.</p>
</div>
<hr>
</div>
<div class="sect2">
<h3 id="result"><code>result</code></h3>
<div class="listingblock">
<div class="title">#include &lt;boost/leaf/result.hpp&gt;</div>
<div class="content">
<pre class="highlight nowrap"><code class="language-c++" data-lang="c++">namespace boost { namespace leaf {

  template &lt;class T&gt;
  class result
  {
  public:

    result() noexcept;
    result( T &amp;&amp; v ) noexcept;
    result( T const &amp; v );

    result( error_id err ) noexcept;
    result( std::error_code const &amp; ec ) noexcept;
    result( std::shared_ptr&lt;polymorphic_context&gt; &amp;&amp; ctx ) noexcept;

    result( result &amp;&amp; r ) noexcept;

    template &lt;class U&gt;
    result( result&lt;U&gt; &amp;&amp; r ) noexcept;

    result &amp; operator=( result &amp;&amp; r ) noexcept;

    template &lt;class U&gt;
    result &amp; operator=( result&lt;U&gt; &amp;&amp; r ) noexcept;

    explicit operator bool() const noexcept;

    T const &amp; value() const;
    T &amp; value();

    T const &amp; operator*() const;
    T &amp; operator*();

    T const * operator-&gt;() const;
    T * operator-&gt;();

    &lt;&lt;unspecified-type&gt;&gt; error() noexcept;

    template &lt;class... E&gt;
    error_id load( E &amp;&amp; ... e ) noexcept;

    template &lt;class... F&gt;
    error_id accumulate( F &amp;&amp; ... f );
  };

  struct bad_result: std::exception { };

} }</code></pre>
</div>
</div>
<div class="paragraph text-right">
<p><a href="#result::result">Constructors</a> | <a href="#result::operator_eq"><code>operator=</code></a> | <a href="#result::operator_bool"><code>operator bool</code></a> | <a href="#result::value"><code>value</code> / <code>operator*</code> / <code>operator-></code></a> | <a href="#result::error"><code>error</code></a> | <a href="#result::load"><code>load</code></a> | <a href="#result::accumulate"><code>accumulate</code></a></p>
</div>
<div class="paragraph">
<p>The <code>result&lt;T&gt;</code> type can be returned by functions which produce a value of type <code>T</code> but may fail doing so.</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">Requirements: </dt>
<dd>
<p><code>T</code> must be movable, and its move constructor may not throw.</p>
</dd>
<dt class="hdlist1">Invariant: </dt>
<dd>
<p>A <code>result&lt;T&gt;</code> object is in one of three states:</p>
<div class="ulist">
<ul>
<li>
<p>Value state, in which case it contains an object of type <code>T</code>, and <code><a href="#result::value">value</a></code>/<code><a href="#result::value">operator*</a></code>/<code><a href="#result::value">operator-></a></code> can be used to access the contained value.</p>
</li>
<li>
<p>Error state, in which case it contains an error ID, and calling <code><a href="#result::value">value</a></code>/<code><a href="#result::value">operator*</a></code>/<code><a href="#result::value">operator-></a></code> throws <code>leaf::bad_result</code>.</p>
</li>
<li>
<p>Error-capture state, which is the same as the Error state, but in addition to the error ID, it holds a <code>std::shared_ptr&lt;<a href="#polymorphic_context">polymorphic_context</a>&gt;</code>.</p>
</li>
</ul>
</div>
</dd>
</dl>
</div>
<div class="paragraph">
<p><code>result&lt;T&gt;</code> objects are nothrow-moveable but are not copyable.</p>
</div>
<hr>
<div class="sect3">
<h4 id="result::result">Constructors</h4>
<div class="listingblock">
<div class="title">#include &lt;boost/leaf/result.hpp&gt;</div>
<div class="content">
<pre class="highlight nowrap"><code class="language-c++" data-lang="c++">namespace boost { namespace leaf {

  template &lt;class T&gt;
  result&lt;T&gt;::result() noexcept;

  template &lt;class T&gt;
  result&lt;T&gt;::result( T &amp;&amp; v ) noexcept;

  template &lt;class T&gt;
  result&lt;T&gt;::result( leaf::error_id err ) noexcept;

  template &lt;class T&gt;
  result&lt;T&gt;::result( std::error_code const &amp; ec ) noexcept;

  template &lt;class T&gt;
  result&lt;T&gt;::result( std::shared_ptr&lt;polymorphic_context&gt; &amp;&amp; ctx ) noexcept;

  template &lt;class T&gt;
  result&lt;T&gt;::result( result &amp;&amp; ) noexcept;

  template &lt;class T&gt;
  template &lt;class U&gt;
  result&lt;T&gt;::result( result&lt;U&gt; &amp;&amp; ) noexcept;

} }</code></pre>
</div>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">Requirements: </dt>
<dd>
<p><code>T</code> must be movable, and its move constructor may not throw.</p>
</dd>
<dt class="hdlist1">Effects: </dt>
<dd>
<p>Establishes the <code>result&lt;T&gt;</code> invariant:</p>
<div class="openblock">
<div class="content">
<div class="ulist">
<ul>
<li>
<p>To get a <code>result&lt;T&gt;</code> in <a href="#result">Value state</a>, initialize it with an object of type <code>T</code> or use the default constructor.</p>
</li>
<li>
<p>To get a <code>result&lt;T&gt;</code> in <a href="#result">Error state</a>, initialize it with an <a href="#error_id"><code>error_id</code></a> object or with  a <code>std::error_code</code>.</p>
</li>
<li>
<p>To get a <code>result&lt;T&gt;</code> in <a href="#result">Error-capture state</a>, initialize it with a <code>std::shared_ptr&lt;<a href="#polymorphic_context">polymorphic_context</a>&gt;</code> (which can be obtained by calling e.g. <a href="#make_shared_context"><code>make_shared_context</code></a>).</p>
</li>
</ul>
</div>
</div>
</div>
<div class="paragraph">
<p>When a <code>result</code> object is initialized with a <code>std::error_code</code> object, it is used to initialize an <code>error_id</code> object, then the behavior is the same as if initialized with <code>error_id</code>.</p>
</div>
</dd>
<dt class="hdlist1">Throws: </dt>
<dd>
<div class="ulist">
<ul>
<li>
<p>Initializing the <code>result&lt;T&gt;</code> in Value state may throw, depending on which constructor of <code>T</code> is invoked;</p>
</li>
<li>
<p>Other constructors do not throw.</p>
</li>
</ul>
</div>
</dd>
</dl>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
A <code>result</code> that is in value state converts to <code>true</code> in boolean contexts. A <code>result</code> that is not in value state converts to <code>false</code> in boolean contexts.
</td>
</tr>
</table>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<code>result&lt;T&gt;</code> objects are nothrow-moveable but are not copyable.
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="result::accumulate"><code>accumulate</code></h4>
<div class="listingblock">
<div class="title">#include &lt;boost/leaf/result.hpp&gt;</div>
<div class="content">
<pre class="highlight nowrap"><code class="language-c++" data-lang="c++">namespace boost { namespace leaf {

  template &lt;class T&gt;
  template &lt;class... F&gt;
  error_id result&lt;T&gt;::accumulate( F &amp;&amp; ... f );

} }</code></pre>
</div>
</div>
<div class="paragraph">
<p>This member function is designed for use in <code>return</code> statements in functions that return <code>result&lt;T&gt;</code> to forward accumulated E-objects to the caller.</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">Effects: </dt>
<dd>
<p>As if <code>error_id(this->error()).accumulate(std::forward&lt;F&gt;(f)&#8230;&#8203;)</code>.</p>
</dd>
<dt class="hdlist1">Returns: </dt>
<dd>
<p><code>*this</code>.</p>
</dd>
</dl>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="result::error"><code>error</code></h4>
<div class="listingblock">
<div class="title">#include &lt;boost/leaf/result.hpp&gt;</div>
<div class="content">
<pre class="highlight nowrap"><code class="language-c++" data-lang="c++">namespace boost { namespace leaf {

  template &lt;class... E&gt;
  &lt;&lt;unspecified-type&gt;&gt; result&lt;T&gt;::error() noexcept;

} }</code></pre>
</div>
</div>
<div class="paragraph">
<p>Returns: A proxy object of unspecified type, implicitly convertible to any instance of the <code>result</code> class template, as well as to <a href="#error_id"><code>error_id</code></a>.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>If the proxy object is converted to some <code>result&lt;U&gt;</code>:</p>
<div class="ulist">
<ul>
<li>
<p>If <code>*this</code> is in <a href="#result">Value state</a>, returns <code>result&lt;U&gt;(error_id())</code>.</p>
</li>
<li>
<p>Otherwise the state of <code>*this</code> is moved into the returned <code>result&lt;U&gt;</code>.</p>
</li>
</ul>
</div>
</li>
<li>
<p>If the proxy object is converted to an <code>error_id</code>:</p>
<div class="ulist">
<ul>
<li>
<p>If <code>*this</code> is in <a href="#result">Value state</a>, returns a default-initialized <a href="#error_id"><code>error_id</code></a> object.</p>
</li>
<li>
<p>If <code>*this</code> is in <a href="#result">Error-capture state</a>, all captured E-objects are <a href="#tutorial-loading">loaded</a> in the calling thread, and the captured <code>error_id</code> value is returned.</p>
</li>
<li>
<p>If <code>*this</code> is in <a href="#result">Error state</a>, returns the stored <code>error_id</code>.</p>
</li>
</ul>
</div>
</li>
<li>
<p>If the proxy object is not used, the state of <code>*this</code> is not modified.</p>
</li>
</ul>
</div>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<i class="fa icon-warning" title="Warning"></i>
</td>
<td class="content">
The returned proxy object refers to <code>*this</code>; avoid holding on to it.
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="result::load"><code>load</code></h4>
<div class="listingblock">
<div class="title">#include &lt;boost/leaf/result.hpp&gt;</div>
<div class="content">
<pre class="highlight nowrap"><code class="language-c++" data-lang="c++">namespace boost { namespace leaf {

  template &lt;class T&gt;
  template &lt;class... E&gt;
  error_id result&lt;T&gt;::load( E &amp;&amp; ... e ) noexcept;

} }</code></pre>
</div>
</div>
<div class="paragraph">
<p>This member function is designed for use in <code>return</code> statements in functions that return <code>result&lt;T&gt;</code> to forward additional E-objects to the caller.</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">Effects: </dt>
<dd>
<p>As if <code>error_id(this->error()).load(std::forward&lt;E&gt;(e)&#8230;&#8203;)</code>.</p>
</dd>
<dt class="hdlist1">Returns: </dt>
<dd>
<p><code>*this</code>.</p>
</dd>
</dl>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="result::operator_eq"><code>operator=</code></h4>
<div class="listingblock">
<div class="title">#include &lt;boost/leaf/result.hpp&gt;</div>
<div class="content">
<pre class="highlight nowrap"><code class="language-c++" data-lang="c++">namespace boost { namespace leaf {

  template &lt;class T&gt;
  result&lt;T&gt; &amp; result&lt;T&gt;::operator=( result &amp;&amp; ) noexcept;

  template &lt;class T&gt;
  template &lt;class U&gt;
  result&lt;T&gt; &amp; result&lt;T&gt;::operator=( result&lt;U&gt; &amp;&amp; ) noexcept;

} }</code></pre>
</div>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">Effects: </dt>
<dd>
<p>Destroys <code>*this</code>, then re-initializes it as if using the appropriate <code>result&lt;T&gt;</code> constructor. Basic exception-safety guarantee.</p>
</dd>
</dl>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="result::operator_bool"><code>operator bool</code></h4>
<div class="listingblock">
<div class="title">#include &lt;boost/leaf/result.hpp&gt;</div>
<div class="content">
<pre class="highlight nowrap"><code class="language-c++" data-lang="c++">namespace boost { namespace leaf {

  template &lt;class T&gt;
  result&lt;T&gt;::operator bool() const noexcept;

} }</code></pre>
</div>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">Returns: </dt>
<dd>
<p>If <code>*this</code> is in <a href="#result">value state</a>, returns <code>true</code>, otherwise returns <code>false</code>.</p>
</dd>
</dl>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="result::value"><code>value</code> / <code>operator*</code> / <code>operator-></code></h4>
<div class="listingblock">
<div class="title">#include &lt;boost/leaf/result.hpp&gt;</div>
<div class="content">
<pre class="highlight nowrap"><code class="language-c++" data-lang="c++">namespace boost { namespace leaf {

  template &lt;class T&gt;
  T const &amp; result&lt;T&gt;::value() const;

  template &lt;class T&gt;
  T &amp; result&lt;T&gt;::value();

  template &lt;class T&gt;
  T const &amp; result&lt;T&gt;::operator*() const;

  template &lt;class T&gt;
  T &amp; result&lt;T&gt;::operator*();

  template &lt;class T&gt;
  T const * result&lt;T&gt;::operator-&gt;() const;

  template &lt;class T&gt;
  T * result&lt;T&gt;::operator-&gt;();

  struct bad_result: std::exception { };

} }</code></pre>
</div>
</div>
<div id="result::bad_result" class="dlist">
<dl>
<dt class="hdlist1">Effects: </dt>
<dd>
<p>If <code>*this</code> is in <a href="#result">value state</a>, returns a reference (or pointer) to the stored value, otherwise throws <code>bad_result</code>.</p>
</dd>
</dl>
</div>
<hr>
</div>
</div>
<div class="sect2">
<h3 id="verbose_diagnostic_info"><code>verbose_diagnostic_info</code></h3>
<div class="listingblock">
<div class="content">
<pre class="highlight nowrap"><code class="language-c++" data-lang="c++">namespace boost { namespace leaf {

  class verbose_diagnostic_info: public error_info
  {
    //Constructors unspecified

    friend std::ostream &amp; operator&lt;&lt;( std::ostream &amp; os, verbose_diagnostic_info const &amp; x );
  };

} }</code></pre>
</div>
</div>
<div class="paragraph">
<p>Handlers passed to error-handling functions such as <a href="#try_handle_some"><code>try_handle_some</code></a>, <a href="#try_handle_all"><code>try_handle_all</code></a> or <a href="#try_catch"><code>try_catch</code></a> may take an argument of type <code>verbose_diagnostic_info const &amp;</code> if they need to print diagnostic information about the error.</p>
</div>
<div class="paragraph">
<p>The message printed by <code>operator&lt;&lt;</code> includes the message printed by <code>error_info</code>, followed by information about E-objects that were communicated to LEAF (to be associated with the error) for which there was no storage available in any active <a href="#context"><code>context</code></a> (these E-objects were discarded by LEAF, because no handler needed them).</p>
</div>
<div class="paragraph">
<p>The additional information includes the types and the values of all such E-objects.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>The behavior of <code>verbose_diagnostic_info</code> (and <a href="#diagnostic_info"><code>diagnostic_info</code></a>) is affected by the value of the macro <code>LEAF_DIAGNOSTICS</code>:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>If it is 1 (the default), LEAF produces <code>verbose_diagnostic_info</code> but only if an active error handling context on the call stack takes an argument of type <code>verbose_diagnostic_info</code>;</p>
</li>
<li>
<p>If it is 0, the <code>verbose_diagnostic_info</code> functionality is stubbed out even for error handling contexts that take an argument of type <code>verbose_diagnostic_info</code>. This could save some cycles on the error path in some programs.</p>
</li>
</ul>
</div>
</td>
</tr>
</table>
</div>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<i class="fa icon-warning" title="Warning"></i>
</td>
<td class="content">
Using <code>verbose_diagnostic_info</code> will likely allocate memory dynamically.
</td>
</tr>
</table>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="macros">Reference: Macros</h2>
<div class="sectionbody">
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
The contents of each Reference section are organized alphabetically.
</td>
</tr>
</table>
</div>
<hr>
<div class="sect2">
<h3 id="LEAF_AUTO"><code>LEAF_AUTO</code></h3>
<div class="listingblock">
<div class="title">#include &lt;boost/leaf/result.hpp&gt;</div>
<div class="content">
<pre class="highlight nowrap"><code class="language-c++" data-lang="c++">#define LEAF_AUTO(v,r)\
  auto &amp;&amp; _r_##v = r;\
  if( !_r_##v )\
    return _r_##v.error();\
  auto &amp; v = _r_##v.value()</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>LEAF_AUTO</code> is useful when calling a function that returns <code>result&lt;T&gt;</code> (other than <code>result&lt;void&gt;</code>), if the desired behavior is to forward any errors to the caller verbatim.</p>
</div>
<div class="paragraph">
<p>Example:</p>
</div>
<div class="listingblock">
<div class="title">Compute two int values, return their sum as a float, using LEAF_AUTO:</div>
<div class="content">
<pre class="highlight nowrap"><code class="language-c++" data-lang="c++">leaf::result&lt;int&gt; compute_value();

leaf::result&lt;float&gt; add_values()
{
  LEAF_AUTO(v1, compute_value());
  LEAF_AUTO(v2, compute_value());
  return v1 + v2;
}</code></pre>
</div>
</div>
<div class="paragraph text-right">
<p><a href="#result"><code>result</code></a></p>
</div>
<div class="paragraph">
<p>Of course, we could write <code>add_value</code> without using <code>LEAF_AUTO</code>. This is equivalent:</p>
</div>
<div class="listingblock">
<div class="title">Compute two int values, return their sum as a float, without LEAF_AUTO:</div>
<div class="content">
<pre class="nowrap">leaf::result&lt;float&gt; add_values()
{
  auto v1 = compute_value();
  if( !v1 )
    return v1.error();

  auto v2 = compute_value();
  if( !v2 )
    return v2.error();

  return v1.value() + v2.value();
}</pre>
</div>
</div>
<hr>
</div>
<div class="sect2">
<h3 id="LEAF_CHECK"><code>LEAF_CHECK</code></h3>
<div class="listingblock">
<div class="title">#include &lt;boost/leaf/result.hpp&gt;</div>
<div class="content">
<pre class="highlight nowrap"><code class="language-c++" data-lang="c++">#define LEAF_CHECK(r)\
  {\
    auto &amp;&amp; _r = r;\
    if(!_r)\
      return _r.error();\
  }</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>LEAF_CHECK</code> is useful when calling a function that returns <code>result&lt;void&gt;</code>, if the desired behavior is to forward any errors to the caller verbatim.</p>
</div>
<div class="paragraph">
<p>Example:</p>
</div>
<div class="listingblock">
<div class="title">Try to send a message, then compute a value, report errors using LEAF_CHECK:</div>
<div class="content">
<pre class="highlight nowrap"><code class="language-c++" data-lang="c++">leaf::result&lt;void&gt; send_message( char const * msg );

leaf::result&lt;int&gt; compute_value();

leaf::result&lt;int&gt; say_hello_and_compute_value()
{
  LEAF_CHECK(send_message("Hello!"));
  return compute_value();
}</code></pre>
</div>
</div>
<div class="paragraph text-right">
<p><a href="#result"><code>result</code></a></p>
</div>
<div class="paragraph">
<p>Equivalent implementation without <code>LEAF_CHECK</code>:</p>
</div>
<div class="listingblock">
<div class="title">Try to send a message, then compute a value, report errors without LEAF_CHECK:</div>
<div class="content">
<pre class="nowrap">leaf::result&lt;float&gt; add_values()
{
  auto r = send_message("Hello!");
  if( !r )
    return r.error();

  return compute_value();
}</pre>
</div>
</div>
<hr>
</div>
<div class="sect2">
<h3 id="LEAF_NEW_ERROR"><code>LEAF_NEW_ERROR</code></h3>
<div class="listingblock">
<div class="title">#include &lt;boost/leaf/result.hpp&gt;</div>
<div class="content">
<pre class="highlight nowrap"><code class="language-c++" data-lang="c++">#define LEAF_NEW_ERROR(...) &lt;&lt;unspecified&gt;&gt;</code></pre>
</div>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">Effects: </dt>
<dd>
<p><code>LEAF_NEW_ERROR(e&#8230;&#8203;)</code> is equivalent to <code>leaf::<a href="#new_error">new_error</a>(e&#8230;&#8203;)</code>, except the current source location is automatically passed to <code>new_error</code> in a <code><a href="#common">e_source_location</a></code> object (in addition to all <code>e&#8230;&#8203;</code> objects).</p>
</dd>
</dl>
</div>
<hr>
</div>
<div class="sect2">
<h3 id="LEAF_EXCEPTION"><code>LEAF_EXCEPTION</code></h3>
<div class="listingblock">
<div class="title">#include &lt;boost/leaf/exception.hpp&gt;</div>
<div class="content">
<pre class="highlight nowrap"><code class="language-c++" data-lang="c++">#define LEAF_EXCEPTION(...) &lt;&lt;unspecified&gt;&gt;</code></pre>
</div>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">Effects: </dt>
<dd>
<p>This is a variadic macro which forwards its arguments to the function template <a href="#exception"><code>exception</code></a>, in addition capturing <code>__FILE__</code>, <code>__LINE__</code> and <code>__FUNCTION__</code>, in a <code><a href="#common">e_source_location</a></code> object.</p>
</dd>
</dl>
</div>
<hr>
</div>
<div class="sect2">
<h3 id="LEAF_THROW"><code>LEAF_THROW</code></h3>
<div class="listingblock">
<div class="title">#include &lt;boost/leaf/exception.hpp&gt;</div>
<div class="content">
<pre class="highlight nowrap"><code class="language-c++" data-lang="c++">#define LEAF_THROW(...) throw LEAF_EXCEPTION(__VA_ARGS__)</code></pre>
</div>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">Effects: </dt>
<dd>
<p>Throws the exception object returned by <a href="#LEAF_EXCEPTION"><code>LEAF_EXCEPTION</code></a>.</p>
</dd>
</dl>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="rationale">Design</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_rationale">Rationale</h3>
<div class="dlist">
<dl>
<dt class="hdlist1">Definition: </dt>
<dd>
<p>Objects that carry information about error conditions are called error objects. For example, objects of type <code>std::error_code</code> are error objects.</p>
</dd>
</dl>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
The following reasoning is independent of the mechanism used to transport error objects, whether it is exception handling or anything else.
</td>
</tr>
</table>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">Definition: </dt>
<dd>
<p>Depending on their interaction with error objects, functions can be classified as follows:</p>
<div class="ulist">
<ul>
<li>
<p><strong>Error-initiating</strong>: functions that initiate error conditions by creating new error objects.</p>
</li>
<li>
<p><strong>Error-neutral</strong>: functions that forward to the caller error objects communicated by lower-level functions they call.</p>
</li>
<li>
<p><strong>Error-handling</strong>: functions that dispose of error objects they have received, recovering normal program operation.</p>
</li>
</ul>
</div>
</dd>
</dl>
</div>
<div class="paragraph">
<p>A crucial observation is that <em>error-initiating</em> functions are typically low-level functions that lack any context and can not determine, much less dictate, the correct program behavior in response to the errors they may initiate. Error conditions which (correctly) lead to termination in some programs may (correctly) be ignored in others; yet other programs may recover from them and resume normal operation.</p>
</div>
<div class="paragraph">
<p>The same reasoning applies to <em>error-neutral</em> functions, but in this case there is the additional issue that the errors they need to communicate, in general, are initiated by functions multiple levels removed from them in the call chain, functions which usually are&#8201;&#8212;&#8201;and should be treated as&#8201;&#8212;&#8201;implementation details. An <em>error-neutral</em> function should not be coupled with error object types communicated by <em>error-initiating</em> functions, for the same reason it should not be coupled with any other aspect of their interface.</p>
</div>
<div class="paragraph">
<p>Finally, <em>error-handling</em> functions, by definition, have the full context they need to deal with at least some, if not all, failures. In their scope it is an absolute necessity that the author knows exactly what information must be communicated by lower level functions in order to recover from each error condition. Specifically, none of this necessary information can be treated as implementation details; in this case, the coupling which is to be avoided in <em>error-neutral</em> functions is in fact desirable.</p>
</div>
<div class="paragraph">
<p>We&#8217;re now ready to define our</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">Design goals: </dt>
<dd>
<div class="ulist">
<ul>
<li>
<p><strong>Error-initiating</strong> functions should be able to communicate all information available to them that is relevant to the failure being reported.</p>
</li>
<li>
<p><strong>Error-neutral</strong> functions should not be coupled with error types communicated by lower-level <em>error-initiating</em> functions. They should be able to augment any failure with additional relevant information available to them.</p>
</li>
<li>
<p><strong>Error-handling</strong> functions should be able to access all the information communicated by <em>error-initiating</em> or <em>error-neutral</em> functions that is needed in order to deal with failures.</p>
</li>
</ul>
</div>
</dd>
</dl>
</div>
<div class="paragraph">
<p>The design goal that <em>error-neutral</em> functions are not coupled with the static type of error objects that pass through them seems to require dynamic polymorphism and therefore dynamic memory allocations (the Boost Exception library meets this design goal at the cost of dynamic memory allocation).</p>
</div>
<div class="paragraph">
<p>As it turns out, dynamic memory allocation is not necessary due to the following</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">Fact: </dt>
<dd>
<div class="ulist">
<ul>
<li>
<p><strong>Error-handling</strong> functions "know" which of the information <em>error-initiating</em> and <em>error-neutral</em> functions are <span class="underline">able</span> to communicate is <span class="underline">actually needed</span> in order to deal with failures in a particular program. Ideally, no resources should be <span class="line-through">used</span> wasted storing or communicating information which is not currently needed to handle errors, <span class="underline">even if it is relevant to the failure</span>.</p>
</li>
</ul>
</div>
</dd>
</dl>
</div>
<div class="paragraph">
<p>For example, if a library function is able to communicate an error code but the program does not need to know the exact error code, then that information may be ignored at the time the library function attempts to communicate it. On the other hand, if an <em>error-handling</em> function needs that information, the memory needed to store it can be reserved statically in its scope.</p>
</div>
<div class="paragraph">
<p>The LEAF functions <a href="#try_handle_some"><code>try_handle_some</code></a>, <a href="#try_handle_all"><code>try_handle_all</code></a> and <a href="#try_catch"><code>try_catch</code></a> implement this idea. Users provide error-handling lambda functions, each taking arguments of the types it needs in order to recover from a particular error condition. LEAF simply provides the space needed to store these types (in the form of a <code>std::tuple</code>, using automatic storage duration) until they are passed to a matching handler.</p>
</div>
<div class="paragraph">
<p>At the time this space is reserved in the scope of an error-handling function, <code>thread_local</code> pointers of the required error types are set to point to the corresponding objects within it. Later on, <em>error-initiating</em> or <em>error-neutral</em> functions wanting to communicate an error object of a given type <code>E</code> use the corresponding <code>thread_local</code> pointer to detect if there is currently storage available for this type:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>If the pointer is not null, storage is available and the object is moved into the pointed storage, exactly once&#8201;&#8212;&#8201;regardless of how many levels of function calls must unwind before an <em>error-handling</em> function is reached.</p>
</li>
<li>
<p>If the pointer is null, storage is not available and the error object is discarded, since no error-handling function makes any use of it in this program&#8201;&#8212;&#8201;saving resources.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>This almost works, except we need to make sure that <em>error-handling</em> functions are protected from accessing stale error objects stored in response to previous failures, which would be a serious logic error. To this end, each occurrence of an error is assigned a unique <a href="#error_id"><code>error_id</code></a>. Each of the <code>E&#8230;&#8203;</code> objects stored in error-handling scopes is assigned an <code>error_id</code> as well, permanently associating it with a particular failure.</p>
</div>
<div class="paragraph">
<p>Thus, to handle a failure we simply match the available error objects (associated with its unique <code>error_id</code>) with the argument types required by each user-provided error-handling function. In terms of C&#43;&#43; exception handling, it is as if we could write something like:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight nowrap"><code class="language-c++" data-lang="c++">try
{
  auto r = process_file();

  //Success, use r:
  ....
}

catch( file_read_error const &amp;, e_file_name const &amp; fn, e_errno const &amp; err )
{
  std::cerr &lt;&lt;
    "Could not read " &lt;&lt; fn &lt;&lt; ", errno=" &lt;&lt; err &lt;&lt; std::endl;
}

catch( file_read_error const &amp;, e_errno const &amp; err )
{
  std::cerr &lt;&lt;
    "File read error, errno=" &lt;&lt; err &lt;&lt; std::endl;
}

catch( file_read_error const &amp; )
{
  std::cerr &lt;&lt; "File read error!" &lt;&lt; std::endl;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Of course this syntax is not valid, so LEAF uses lambda functions to express the same idea:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight nowrap"><code class="language-c++" data-lang="c++">leaf::try_catch(

  []
  {
    auto r = process_file(); //Throws in case of failure, E-objects stored inside the try_catch scope

    //Success, use r:
    ....
  }

  []( leaf::catch_&lt;file_read_error&gt;, e_file_name const &amp; fn, e_errno const &amp; err )
  {
    std::cerr &lt;&lt;
      "Could not read " &lt;&lt; fn &lt;&lt; ", errno=" &lt;&lt; err &lt;&lt; std::endl;
  },

  []( leaf::catch_&lt;file_read_error&gt;, e_errno const &amp; err )
  {
    std::cerr &lt;&lt;
      "File read error, errno=" &lt;&lt; err &lt;&lt; std::endl;
  },

  []( leaf::catch_&lt;file_read_error&gt; )
  {
    std::cerr &lt;&lt; "File read error!" &lt;&lt; std::endl;
  } );</code></pre>
</div>
</div>
<div class="paragraph text-right">
<p><a href="#try_catch"><code>try_catch</code></a> | <a href="#catch_"><code>catch_</code></a> | <a href="#e_file_name"><code>e_file_name</code></a> | <a href="#e_errno"><code>e_errno</code></a></p>
</div>
<div class="paragraph">
<p>Similar syntax works without exception handling as well. Below is the same snippet, written using <code><a href="#result">result</a>&lt;T&gt;</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight nowrap"><code class="language-c++" data-lang="c++">return leaf::try_handle_some(

  []() -&gt; leaf::result&lt;void&gt;
  {
    LEAF_AUTO(r, process_file()); //In case of errors, E-objects are stored inside the try_handle_some scope

    //Success, use r:
    ....

    return { };
  }

  []( leaf::match&lt;error_enum, file_read_error&gt;, e_file_name const &amp; fn, e_errno const &amp; err )
  {
    std::cerr &lt;&lt;
      "Could not read " &lt;&lt; fn &lt;&lt; ", errno=" &lt;&lt; err &lt;&lt; std::endl;
  },

  []( leaf::match&lt;error_enum, file_read_error&gt;, e_errno const &amp; err )
  {
    std::cerr &lt;&lt;
      "File read error, errno=" &lt;&lt; err &lt;&lt; std::endl;
  },

  []( leaf::match&lt;error_enum, file_read_error&gt; )
  {
    std::cerr &lt;&lt; "File read error!" &lt;&lt; std::endl;
  } );</code></pre>
</div>
</div>
<div class="paragraph text-right">
<p><a href="#result"><code>result</code></a> | <a href="#try_handle_some"><code>try_handle_some</code></a> | <a href="#match"><code>match</code></a> | <a href="#e_file_name"><code>e_file_name</code></a> | <a href="#e_errno"><code>e_errno</code></a></p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
Please post questions and feedback on the Boost Developers Mailing List (LEAF is not part of Boost).
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect2">
<h3 id="exception_specifications">Critique 1: Error Types Do Not Participate in Function Signatures</h3>
<div class="paragraph">
<p>A knee-jerk critique of the LEAF design is that it does not statically enforce that each possible error condition is recognized and handled by the program. One idea I&#8217;ve heard from multiple sources is to add <code>E&#8230;&#8203;</code> parameter pack to <code>result&lt;T&gt;</code>, essentially turning it into <code>expected&lt;T,E&#8230;&#8203;&gt;</code>, so we could write something along these lines:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight nowrap"><code class="language-c++" data-lang="c++">expected&lt;T, E1, E2, E3&gt; f() noexcept; <i class="conum" data-value="1"></i><b>(1)</b>

expected&lt;T, E1, E3&gt; g() noexcept <i class="conum" data-value="2"></i><b>(2)</b>
{
  if( expected&lt;T, E1, E2, E3&gt; r = f() )
  {
    return r; //Success, return the T
  }
  else
  {
    return r.handle_error&lt;E2&gt;( [] ( .... ) <i class="conum" data-value="3"></i><b>(3)</b>
      {
        ....
      } );
  }
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td><code>f</code> may only return error objects of type <code>E1</code>, <code>E2</code>, <code>E3</code>.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td><code>g</code> narrows that to only <code>E1</code> and <code>E3</code>.</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>Because <code>g</code> may only return error objects of type <code>E1</code> and <code>E3</code>, it uses <code>handle_error</code> to deal with <code>E2</code>. In case <code>r</code> contains <code>E1</code> or <code>E3</code>, <code>handle_error</code> simply returns <code>r</code>, narrowing the error type parameter pack from <code>E1, E2, E3</code> down to <code>E1, E3</code>. If <code>r</code> contains an <code>E2</code>, <code>handle_error</code> calls the supplied lambda, which is required to return one of <code>E1</code>, <code>E3</code> (or a valid <code>T</code>).</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>The motivation here is to help avoid bugs in functions that handle errors that pop out of <code>g</code>: as long as the programmer deals with <code>E1</code> and <code>E3</code>, he can rest assured that no error is left unhandled.</p>
</div>
<div class="paragraph">
<p>Congratulations, we&#8217;ve just discovered exception specifications. The difference is that exception specifications, before being removed from C&#43;&#43;, were enforced dynamically, while this idea is equivalent to statically-enforced exception specifications, like they are in Java.</p>
</div>
<div class="paragraph">
<p>Why not statically enforce exception specifications?</p>
</div>
<div class="quoteblock">
<blockquote>
The short answer is that nobody knows how to fix exception specifications in any language, because the dynamic enforcement C&#43;&#43; chose has only different (not greater or fewer) problems than the static enforcement Java chose. &#8230;&#8203; When you go down the Java path, people love exception specifications until they find themselves all too often encouraged, or even forced, to add <code>throws Exception</code>, which immediately renders the exception specification entirely meaningless. (Example: Imagine writing a Java generic that manipulates an arbitrary type <code>T</code>).<sup class="footnote">[<a id="_footnoteref_1" class="footnote" href="#_footnotedef_1" title="View footnote.">1</a>]</sup>
</blockquote>
<div class="attribution">
&#8212; Herb Sutter
</div>
</div>
<div class="paragraph">
<p>Consider again the example above: assuming we don&#8217;t want important error-related information to be lost, values of type <code>E1</code> and/or <code>E3</code> must be able to encode any <code>E2</code> value dynamically. But like Sutter points out, in generic contexts we don&#8217;t know what errors may result in calling a user-supplied function. The only way around that is to specify a single type (e.g. <code>std::error_code</code>) that can communicate any and all errors, which ultimately defeats the idea of using static type checking to enforce correct error handling.</p>
</div>
<div class="paragraph">
<p>That said, in every program there are certain <em>error-handling</em> functions (e.g. <code>main</code>) which are required to handle any error, and it is highly desirable to be able to enforce this requirement at compile-time. In LEAF, the <code>try_handle_all</code> function implements this idea: if the user fails to supply at least one handler that will match any error, the result is a compile error. This guarantees that the scope invoking <code>try_handle_all</code> is prepared to recover from any failure.</p>
</div>
<hr>
</div>
<div class="sect2">
<h3 id="translation">Critique 2: LEAF Does Not Facilitate Mapping Between Different Error Types</h3>
<div class="paragraph">
<p>Most C&#43;&#43; programs use multiple C and C&#43;&#43; libraries, and each library may provide its own system of error codes. But because it is difficult to define static interfaces that can communicate arbitrary error code types, a popular idea is to map each library-specific error code to a common program-wide enum.</p>
</div>
<div class="paragraph">
<p>For example, if we have&#8201;&#8212;&#8201;</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight nowrap"><code class="language-c++" data-lang="c++">namespace lib_a
{
  enum error
  {
    ok,
    ec1,
    ec2,
    ....
  };
}

namespace lib_b
{
  enum error
  {
    ok,
    ec1,
    ec2,
    ....
  };
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>&#8201;&#8212;&#8201;we could define:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight nowrap"><code class="language-c++" data-lang="c++">namespace program
{
  enum error
  {
    ok,
    lib_a_ec1,
    lib_a_ec2,
    ....
    lib_b_ec1,
    lib_b_ec2,
    ....
  };
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>An error-handling library could provide conversion API that uses the C&#43;&#43; static type system to automate the mapping between the different error enums. For example, it may define a class template <code>result&lt;T,E&gt;</code> with value-or-error variant semantics, so that:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>lib_a</code> errors are transported in <code>result&lt;T,lib_a::error&gt;</code>,</p>
</li>
<li>
<p><code>lib_b</code> errors are transported in <code>result&lt;T,lib_b::error&gt;</code>,</p>
</li>
<li>
<p>then both are automatically mapped to <code>result&lt;T,program::error&gt;</code> once control reaches the appropriate scope.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>There are several problems with this idea:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>It is prone to errors, both during the initial implementation as well as under maintenance.</p>
</li>
<li>
<p>It does not compose well. For example, if both of <code>lib_a</code> and <code>lib_b</code> use <code>lib_c</code>, errors that originate in <code>lib_c</code> would be obfuscated by the different APIs exposed by each of <code>lib_a</code> and <code>lib_b</code>.</p>
</li>
<li>
<p>It presumes that all errors in the program can be specified by exactly one error code, which is false.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>To elaborate on the last point, consider a program that attempts to read a configuration file from three different locations: in case all of the attempts fail, it should communicate each of the failures. In theory <code>result&lt;T,E&gt;</code> handles this case well:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight nowrap"><code class="language-c++" data-lang="c++">struct attempted_location
{
  std::string path;
  error ec;
};

struct config_error
{
  attempted_location current_dir, user_dir, app_dir;
};

result&lt;config,config_error&gt; read_config();</code></pre>
</div>
</div>
<div class="paragraph">
<p>This looks nice, until we realize what the <code>config_error</code> type means for the automatic mapping API we wanted to define: an <code>enum</code> can not represent a <code>struct</code>. It is a fact that we can not assume that all error conditions can be fully specified by an <code>enum</code>; an error handling library must be able to transport arbitrary static types efficiently.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
While the <code>leaf::<a href="#result">result</a>&lt;T&gt;</code> class template does have value-or-error semantics, it does not carry the actual error objects. Instead, they are forwarded directly to the appropriate error-handling scope and their types do not participate in function signatures.
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="errors_are_not_implementation_details">Critique 3: LEAF Does Not Treat Low Level Error Types as Implementation Details</h3>
<div class="paragraph">
<p>This critique is a combination of <a href="#exception_specifications">Critique 1</a> and <a href="#translation">Critique 2</a>, but it deserves special attention. Let&#8217;s consider this example using LEAF:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight nowrap"><code class="language-c++" data-lang="c++">leaf::result&lt;std::string&gt; read_line( reader &amp; r );

leaf::result&lt;parsed_line&gt; parse_line( std::string const &amp; line );

leaf::result&lt;parsed_line&gt; read_and_parse_line( reader &amp; r )
{
  LEAF_AUTO(line, read_line(r)); <i class="conum" data-value="1"></i><b>(1)</b>
  LEAF_AUTO(parsed, parse_line(line)); <i class="conum" data-value="2"></i><b>(2)</b>
  return parsed;
}</code></pre>
</div>
</div>
<div class="paragraph text-right">
<p><a href="#result"><code>result</code></a> | <a href="#LEAF_AUTO"><code>LEAF_AUTO</code></a></p>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Read a line, forward errors to the caller.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>Parse the line, forward errors to the caller.</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>The objection is that LEAF will forward verbatim the errors that are detected in <code>read_line</code> or <code>parse_line</code> to the caller of  <code>read_and_parse_line</code>. The premise of this objection is that such low-level errors are implementation details and should be treated as such. Under this premise, <code>read_and_parse_line</code> should act as a translator of sorts, in both directions:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>When called, it should translate its own arguments to call <code>read_line</code> and <code>parse_line</code>;</p>
</li>
<li>
<p>If an error is detected, it should translate the errors from the error types returned by <code>read_line</code> and <code>parse_line</code> to a higher-level type.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>The motivation is to isolate the caller of <code>read_and_parse_line</code> from its implementation details <code>read_line</code> and <code>parse_line</code>.</p>
</div>
<div class="paragraph">
<p>There are two possible ways to implement this translation:</p>
</div>
<div class="paragraph">
<p><strong>1)</strong> <code>read_and_parse_line</code> understands the semantics of <strong>all possible failures</strong> that may be reported by both <code>read_line</code> and <code>parse_line</code>, implementing a non-trivial mapping which both <em>erases</em> information that is considered not relevant to its caller, as well as encodes <em>different</em> semantics in the error it reports. In this case <code>read_and_parse_line</code> assumes full responsibility for describing precisely what went wrong, using its own type specifically designed for the job.</p>
</div>
<div class="paragraph">
<p><strong>2)</strong> <code>read_and_parse_line</code> returns an error object that essentially indicates which of the two inner functions failed, and also transports the original error object without understanding its semantics and without any loss of information, wrapping it in a new error type.</p>
</div>
<div class="paragraph">
<p>The problem with <strong>1)</strong> is that typically the caller of <code>read_and_parse_line</code> is not going to handle the error, but it does need to forward it to its caller. In our attempt to protect the <strong>one</strong> error-handling function from "implementation details", we&#8217;ve coupled the interface of <strong>all</strong> intermediate error-neutral functions with the static types of errors they do not understand and do not handle.</p>
</div>
<div class="paragraph">
<p>Consider the case where <code>read_line</code> communicates <code>errno</code> in its errors. What is <code>read_and_parse_line</code> supposed to do with e.g. <code>EACCESS</code>? Turn it into <code>READ_AND_PARSE_LINE_EACCESS</code>? To what end, other than to obfuscate the original (already complex and platform-specific) semantics of <code>errno</code>?</p>
</div>
<div class="paragraph">
<p>And what if the call to <code>read</code> is polymorphic, which is also typical? What if it involves a user-supplied function object? What kinds of errors does it return and why should <code>read_and_parse_line</code> care?</p>
</div>
<div class="paragraph">
<p>Therefore, we&#8217;re left with <strong>2)</strong>. There&#8217;s almost nothing wrong with this option, since it passes any and all error-related information from lower level functions without any loss. However, using a wrapper type to grant (presumably dynamic) access to any lower-level error type it may be transporting is cumbersome and (like Niall Douglas <a href="#interoperability">explains</a>) in general probably requires dynamic allocations. It is better to use independent error types that communicate the additional information not available in the original error object, while error handlers rely on LEAF to provide efficient access to any and all low-level error types, as needed.</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_alternatives_to_leaf">Alternatives to LEAF</h2>
<div class="sectionbody">
<div class="ulist">
<ul>
<li>
<p><a href="https://www.boost.org/doc/libs/release/libs/exception/doc/boost-exception.html">Boost Exception</a></p>
</li>
<li>
<p><a href="https://ned14.github.io/outcome">Boost Outcome</a></p>
</li>
<li>
<p><a href="https://github.com/pdimov/variant2"><code>variant2</code> / <code>expected&lt;T,E&#8230;&#8203;&gt;</code></a></p>
</li>
<li>
<p><a href="https://github.com/TartanLlama/expected"><code>tl::expected</code></a></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Below we offer a comparison of LEAF to Boost Exception and to Boost Outcome.</p>
</div>
<div class="sect2">
<h3 id="boost_exception">Comparison to Boost Exception</h3>
<div class="paragraph">
<p>While LEAF can be used without exception handling, in the use case when errors are communicated by throwing exceptions, it can be viewed as a better, more efficient alternative to Boost Exception. LEAF has the following advantages over Boost Exception:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>LEAF does not allocate memory dynamically;</p>
</li>
<li>
<p>LEAF does not waste system resources communicating error objects not used by specific error handling functions;</p>
</li>
<li>
<p>LEAF does not store the error objects in the exception object, and therefore it is able to augment exceptions thrown by external libraries (Boost Exception can only augment exceptions of types that derive from <code>boost::exception</code>).</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>The following tables outline the differences between the two libraries which should be considered when code that uses Boost Exception is refactored to use LEAF instead:</p>
</div>
<table class="tableblock frame-all grid-all stripes-none stretch">
<caption class="title">Table 2. Defining a custom type for transporting values of type T</caption>
<colgroup>
<col style="width: 50%;">
<col style="width: 50%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Boost Exception</th>
<th class="tableblock halign-left valign-top">LEAF</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><div class="content"><div class="listingblock">
<div class="content">
<pre class="highlight nowrap"><code class="language-c++" data-lang="c++">typedef error_info&lt;struct my_info_,T&gt; my_info;</code></pre>
</div>
</div>
<div class="paragraph text-right">
<p><a href="https://www.boost.org/doc/libs/release/libs/exception/doc/error_info.html"><code>boost::error_info</code></a></p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="listingblock">
<div class="content">
<pre class="highlight nowrap"><code class="language-c++" data-lang="c++">struct my_info { T value; };</code></pre>
</div>
</div></div></td>
</tr>
</tbody>
</table>
<table class="tableblock frame-all grid-all stripes-none stretch">
<caption class="title">Table 3. Passing arbitrary info at the point of the throw</caption>
<colgroup>
<col style="width: 50%;">
<col style="width: 50%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Boost Exception</th>
<th class="tableblock halign-left valign-top">LEAF</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><div class="content"><div class="listingblock">
<div class="content">
<pre class="highlight nowrap"><code class="language-c++" data-lang="c++">throw my_exception() &lt;&lt;
  my_info(x) &lt;&lt;
  my_info(y);</code></pre>
</div>
</div>
<div class="paragraph text-right">
<p><a href="https://www.boost.org/doc/libs/release/libs/exception/doc/exception_operator_shl.html"><code>operator&lt;&lt;</code></a></p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="listingblock">
<div class="content">
<pre class="highlight nowrap"><code class="language-c++" data-lang="c++">throw leaf::exception( my_exception(),
  my_info{x},
  my_info{y} );</code></pre>
</div>
</div>
<div class="paragraph text-right">
<p><a href="#exception"><code>exception</code></a></p>
</div></div></td>
</tr>
</tbody>
</table>
<table class="tableblock frame-all grid-all stripes-none stretch">
<caption class="title">Table 4. Augmenting exceptions in error-neutral contexts</caption>
<colgroup>
<col style="width: 50%;">
<col style="width: 50%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Boost Exception</th>
<th class="tableblock halign-left valign-top">LEAF</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><div class="content"><div class="listingblock">
<div class="content">
<pre class="highlight nowrap"><code class="language-c++" data-lang="c++">try
{
  f();
}
catch( boost::exception &amp; e )
{
  e &lt;&lt; my_info(x);
  throw;
}</code></pre>
</div>
</div>
<div class="paragraph text-right">
<p><a href="https://www.boost.org/doc/libs/release/libs/exception/doc/exception.html"><code>boost::exception</code></a> | <a href="https://www.boost.org/doc/libs/release/libs/exception/doc/exception_operator_shl.html"><code>operator&lt;&lt;</code></a></p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="listingblock">
<div class="content">
<pre class="highlight nowrap"><code class="language-c++" data-lang="c++">auto load = leaf::preload( my_info{x} );

f();</code></pre>
</div>
</div>
<div class="paragraph text-right">
<p><a href="#preload"><code>preload</code></a></p>
</div></div></td>
</tr>
</tbody>
</table>
<table class="tableblock frame-all grid-all stripes-none stretch">
<caption class="title">Table 5. Obtaining arbitrary info at the point of the catch</caption>
<colgroup>
<col style="width: 50%;">
<col style="width: 50%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Boost Exception</th>
<th class="tableblock halign-left valign-top">LEAF</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><div class="content"><div class="listingblock">
<div class="content">
<pre class="highlight nowrap"><code class="language-c++" data-lang="c++">try
{
  f();
}
catch( my_exception &amp; e )
{
  if( T * v = get_error_info&lt;my_info&gt;(e) )
  {
    //my_info is available in e.
  }
}</code></pre>
</div>
</div>
<div class="paragraph text-right">
<p><a href="https://www.boost.org/doc/libs/release/libs/exception/doc/get_error_info.html"><code>boost::get_error_info</code></a></p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="listingblock">
<div class="content">
<pre class="highlight nowrap"><code class="language-c++" data-lang="c++">leaf::try_catch(
  []
  {
    f();
  }
  []( leaf::catch_&lt;my_exception&gt;, my_info const &amp; x )
  {
    //my_info is available with
    //the caught exception.
  } );</code></pre>
</div>
</div>
<div class="paragraph text-right">
<p><a href="#try_catch"><code>try_catch</code></a></p>
</div></div></td>
</tr>
</tbody>
</table>
<table class="tableblock frame-all grid-all stripes-none stretch">
<caption class="title">Table 6. Transporting of E-objects</caption>
<colgroup>
<col style="width: 50%;">
<col style="width: 50%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Boost Exception</th>
<th class="tableblock halign-left valign-top">LEAF</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>All supplied <a href="https://www.boost.org/doc/libs/release/libs/exception/doc/error_info.html"><code>boost::error_info</code></a> objects are allocated dynamically and stored in the <a href="https://www.boost.org/doc/libs/release/libs/exception/doc/exception.html"><code>boost::exception</code></a> subobject of exception objects.</p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>User-defined error objects are stored statically in the scope of <a href="#try_catch"><code>try_catch</code></a>, but only if their types are needed to handle errors; otherwise they are discarded.</p>
</div></div></td>
</tr>
</tbody>
</table>
<table class="tableblock frame-all grid-all stripes-none stretch">
<caption class="title">Table 7. Transporting of E-objects across thread boundaries</caption>
<colgroup>
<col style="width: 50%;">
<col style="width: 50%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Boost Exception</th>
<th class="tableblock halign-left valign-top">LEAF</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p><a href="https://www.boost.org/doc/libs/release/libs/exception/doc/exception_ptr.html"><code>boost::exception_ptr</code></a> automatically captures <a href="https://www.boost.org/doc/libs/release/libs/exception/doc/error_info.html"><code>boost::error_info</code></a> objects stored in a <code>boost::exception</code> and can transport them across thread boundaries.</p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>Transporting error objects across thread boundaries requires the use of <a href="#capture"><code>capture</code></a>.</p>
</div></div></td>
</tr>
</tbody>
</table>
<table class="tableblock frame-all grid-all stripes-none stretch">
<caption class="title">Table 8. Printing of error objects in automatically-generated diagnostic information messages</caption>
<colgroup>
<col style="width: 50%;">
<col style="width: 50%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Boost Exception</th>
<th class="tableblock halign-left valign-top">LEAF</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p><code>boost::error_info</code> types may define conversion to <code>std::string</code> by providing <code>to_string</code> overloads <strong>or</strong> by overloading <code>operator&lt;&lt;</code> for <code>std::ostream</code>.</p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>LEAF does not use <code>to_string</code>. Error types may define <code>operator&lt;&lt;</code> overloads for <code>std::ostream</code>.</p>
</div></div></td>
</tr>
</tbody>
</table>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<i class="fa icon-warning" title="Warning"></i>
</td>
<td class="content">
<div class="paragraph">
<p>The fact that Boost Exception stores all supplied <code>boost::error_info</code> objects&#8201;&#8212;&#8201;while LEAF discards them if they aren&#8217;t needed&#8201;&#8212;&#8201;affects the completeness of the message we get when we print <code>leaf::<a href="#diagnostic_info">diagnostic_info</a></code> objects, compared to the string returned by <a href="https://www.boost.org/doc/libs/release/libs/exception/doc/diagnostic_information.html"><code>boost::diagnostic_information</code></a>.</p>
</div>
<div class="paragraph">
<p>If the user requires a complete diagnostic message, the solution is to use <code>leaf::<a href="#verbose_diagnostic_info">verbose_diagnostic_info</a></code>. In this case, before unused error objects are discarded by LEAF, they are converted to string and printed. Note that this allocates memory dynamically.</p>
</div>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect2">
<h3 id="boost_outcome">Comparison to Boost Outcome</h3>
<div class="sect3">
<h4 id="_design_differences">Design Differences</h4>
<div class="paragraph">
<p>Like LEAF, the <a href="https://ned14.github.io/outcome">Boost Outcome</a> library is designed to work in low latency environments. It provides two class templates, <code>result&lt;&gt;</code> and <code>outcome&lt;&gt;</code>:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>result&lt;T,EC,NVP&gt;</code> can be used as the return type in <code>noexcept</code> functions which may fail, where <code>T</code> specifies the type of the return value in case of success, while <code>EC</code> is an "error code" type. Semantically, <code>result&lt;T,EC&gt;</code> is similar to <code>std::variant&lt;T,EC&gt;</code>. Naturally, <code>EC</code> defaults to <code>std::error_code</code>.</p>
</li>
<li>
<p><code>outcome&lt;T,EC,EP,NVP&gt;</code> is similar to <code>result&lt;&gt;</code>, but in case of failure, in addition to the "error code" type <code>EC</code> it can hold a "pointer" object of type <code>EP</code>, which defaults to <code>std::exception_ptr</code>.</p>
</li>
</ul>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<code>NVP</code> is a policy type used to customize the behavior of <code>.value()</code> when the <code>result&lt;&gt;</code> or the <code>outcome&lt;&gt;</code> object contains an error.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>The idea is to use <code>result&lt;&gt;</code> to communicate failures which can be fully specified by an "error code", and <code>outcome&lt;&gt;</code> to communicate failures that require additional information.</p>
</div>
<div class="paragraph">
<p>Another way to describe this design is that <code>result&lt;&gt;</code> is used when it suffices to return an error object of some static type <code>EC</code>, while <code>outcome&lt;&gt;</code> can also transport a polymorphic error object, using the pointer type <code>EP</code>.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
In the default configuration of <code>outcome&lt;T&gt;</code> the additional information&#8201;&#8212;&#8201;or the additional polymorphic object&#8201;&#8212;&#8201;is an exception object held by <code>std::exception_ptr</code>. This targets the use case when an exception thrown by a lower-level library function needs to be transported through some intermediate contexts that are not exception-safe, to a higher-level context able to handle it. LEAF directly supports this use as well, see <a href="#exception_to_result"><code>exception_to_result</code></a>.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Similar reasoning drives the design of LEAF as well. The difference is that while both libraries recognize the need to transport "something else" in addition to an "error code", LEAF provides an efficient solution to this problem, while Outcome shifts this burden to the user.</p>
</div>
<div class="paragraph">
<p>The <code>leaf::result&lt;&gt;</code> template deletes both <code>EC</code> and <code>EP</code>, which decouples it from the type of the error objects that are transported in case of a failure. This enables lower-level functions to freely communicate anything and everything they "know" about the failure: error code, even multiple error codes, file names, request IDs, etc. At the same time, the higher-level error-handling functions control which of this information is needed in a specific client program and which is not. This is ideal, because:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Authors of lower-level library functions lack context to determine which of the information that is both relevant to the error <em>and</em> naturally available to them needs to be communicated in order for a particular client program to recover from that error;</p>
</li>
<li>
<p>Authors of higher-level error-handling functions can easily and confidently make this determination, which they communicate naturally to LEAF, by simply writing the different error handlers. LEAF automatically and efficiently transports the needed E-objects while discarding the ones handlers don&#8217;t use, saving resources.</p>
</li>
</ul>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
The LEAF examples include an adaptation of the program from the <a href="https://ned14.github.io/outcome/tutorial/essential/result/">Boost Outcome <code>result&lt;&gt;</code> tutorial</a>. You can <a href="https://github.com/zajo/leaf/blob/master/examples/print_half.cpp?ts=4">view it on GitHub</a>.
</td>
</tr>
</table>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
Programs using LEAF for error-handling are not required to use <code>leaf::result&lt;T&gt;</code>; for example, it is possible to use <code>outcome::result&lt;T&gt;</code> with LEAF.
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="interoperability">The Interoperability Problem</h4>
<div class="paragraph">
<p>The Boost Outcome documentation discusses the important problem of bringing together multiple libraries&#8201;&#8212;&#8201;each using its own error reporting mechanism&#8201;&#8212;&#8201;and incorporating them in a robust error handling infrastructure in a client program.</p>
</div>
<div class="paragraph">
<p>Users are advised that whenever possible they should use a common error handling system throughout their entire codebase, but because this is not practical, both the <code>result&lt;&gt;</code> and the <code>outcome&lt;&gt;</code> templates can carry user-defined "payloads".</p>
</div>
<div class="paragraph">
<p>The following analysis is from the Boost Outcome documentation:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="paragraph">
<p>If library A uses <code>result&lt;T, libraryA::failure_info&gt;</code>, and library B uses <code>result&lt;T, libraryB::error_info&gt;</code> and so on, there becomes a problem for the application writer who is bringing in these third party dependencies and tying them together into an application. As a general rule, each third party library author will not have built in explicit interoperation support for unknown other third party libraries. The problem therefore lands with the application writer.</p>
</div>
<div class="paragraph">
<p>The application writer has one of three choices:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>In the application, the form of result used is <code>result&lt;T, std::variant&lt;E1, E2, &#8230;&#8203;&gt;&gt;</code> where <code>E1, E2 …</code> are the failure types for every third party library in use in the application. This has the advantage of preserving the original information exactly, but comes with a certain amount of use inconvenience and maybe excessive coupling between high level layers and implementation detail.</p>
</li>
<li>
<p>One can translate/map the third party’s failure type into the application’s failure type at the point of the failure exiting the third party library and entering the application. One might do this, say, with a C preprocessor macro wrapping every invocation of the third party API from the application. This approach may lose the original failure detail, or mis-map under certain circumstances if the mapping between the two systems is not one-one.</p>
</li>
<li>
<p>One can type erase the third party’s failure type into some application failure type, which can later be reconstituted if necessary. <strong>This is the cleanest solution with the least coupling issues and no problems with mis-mapping</strong>, but it almost certainly requires the use of <code>malloc</code> which the previous two did not.</p>
</li>
</ol>
</div>
</div>
</div>
<div class="paragraph">
<p>The analysis above (emphasis added) is clear and precise, but LEAF and Boost Outcome tackle the interoperability problem differently:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>The Boost Outcome design asserts that the "cleanest" solution based on type-erasure is suboptimal ("almost certainly requires the use of <code>malloc</code>"), and instead provides a system for injecting custom converters into the <code>outcome::convert</code> namespace, used to translate between library-specific and program-wide error types, even though this approach "may lose the original failure detail".</p>
</li>
<li>
<p>The LEAF design asserts that coupling the signatures of <a href="#rationale">error-neutral</a> functions with the static types of the error objects they need to forward to the caller <a href="#translation">does not scale</a>, and instead transports error objects directly to error-handling scopes where they are stored statically, effectively implementing the third choice outlined above (without the use of <code>malloc</code>).</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Further, consider that Outcome aims to hopefully become <em>the</em> one error-handling API all libraries would use, and in theory everyone would benefit from uniformity and standardization. But the reality is that this is wishful thinking. In fact, that reality is reflected in the design of <code>outcome::result&lt;&gt;</code>, in its failure to commit to using <code>std::error_code</code> for its intended purpose: to become <em>the</em> standard type for transporting error codes. The fact is that <code>std::error_code</code> became <em>yet another</em> error code type programmers need to understand and support.</p>
</div>
<div class="paragraph">
<p>In contrast, the design of LEAF acknowledges that C&#43;&#43; programmers don&#8217;t even agree on what a string is. If your project uses 10 different libraries, this probably means 15 different ways to report errors, sometimes across uncooperative interfaces (e.g. C APIs). LEAF helps you get the job done elegantly and efficiently.</p>
</div>
</div>
<div class="sect3">
<h4 id="_benchmark">Benchmark</h4>
<div class="paragraph">
<p><a href="https://github.com/zajo/leaf/blob/master/benchmark/benchmark.md">This benchmark</a> compares the performance of LEAF and Boost Outcome.</p>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="distribution">Distribution</h2>
<div class="sectionbody">
<div class="paragraph">
<p>The source code is <a href="https://github.com/zajo/leaf">available</a> on GitHub.</p>
</div>
<div class="paragraph">
<p>Copyright (c) 2018-2019 Emil Dotchevski. Distributed under the <a href="http://www.boost.org/LICENSE_1_0.txt">Boost Software License, Version 1.0</a>.</p>
</div>
<div class="paragraph">
<p>Please post questions and feedback on the Boost Developers Mailing List (LEAF is not part of Boost).</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="portability">Portability</h2>
<div class="sectionbody">
<div class="paragraph">
<p>LEAF requires a C&#43;&#43;11 compiler.</p>
</div>
<div class="paragraph">
<p>See unit test matrix at <a href="https://travis-ci.org/zajo/leaf">Travis-CI</a> and <a href="https://ci.appveyor.com/project/zajo/leaf">AppVeyor</a>.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="building">Building</h2>
<div class="sectionbody">
<div class="paragraph">
<p>LEAF is a header-only library and it requires no building. It does not depend on Boost or on any other library.</p>
</div>
<div class="paragraph">
<p>The unit tests can be run with Boost Build or with <a href="https://mesonbuild.com">Meson Build</a>. To run the unit tests:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>If using Boost Build:</p>
<div class="olist loweralpha">
<ol class="loweralpha" type="a">
<li>
<p>Clone LEAF under your <code>boost/libs</code> directory.</p>
</li>
<li>
<p>Execute:</p>
<div class="listingblock">
<div class="content">
<pre class="highlight nowrap"><code class="language-sh" data-lang="sh">cd leaf/test
../../../b2</code></pre>
</div>
</div>
</li>
</ol>
</div>
</li>
<li>
<p>If using Meson Build:</p>
<div class="olist loweralpha">
<ol class="loweralpha" type="a">
<li>
<p>Clone LEAF into any local directory.</p>
</li>
<li>
<p>Execute:</p>
<div class="listingblock">
<div class="content">
<pre class="highlight nowrap"><code class="language-sh" data-lang="sh">cd leaf
meson bld/debug
cd bld/debug
meson test</code></pre>
</div>
</div>
</li>
</ol>
</div>
</li>
</ol>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_configuration_macros">Configuration Macros</h2>
<div class="sectionbody">
<div class="paragraph">
<p>The following configuration macros are recognized:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>LEAF_DIAGNOSTICS</code>: Defining this macro to <code>0</code> stubs out both <a href="#diagnostic_info"><code>diagnostic_info</code></a> and <a href="#verbose_diagnostic_info"><code>verbose_diagnostic_info</code></a>, which could improve the performance of the error path in some programs (if the macro is left undefined, LEAF defines it as <code>1</code>).</p>
</li>
<li>
<p><code>LEAF_NO_EXCEPTIONS</code>: Disables all exception handling support. If left undefined, LEAF defines it based on the compiler configuration (e.g. <code>-fno-exceptions</code>).</p>
</li>
<li>
<p><code>LEAF_NO_THREADS</code>: Disable all multi-thread support.</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_acknowledgements">Acknowledgements</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Special thanks to Peter Dimov and Sorin Fetche.</p>
</div>
<div class="paragraph">
<p>Ivo Belchev, Sean Palmer, Jason King, Vinnie Falco, Glen Fernandes, Nir Friedman, Augustín Bergé&#8201;&#8212;&#8201;thanks for the valuable feedback.</p>
</div>
<div class="paragraph">
<p>Documentation rendered by <a href="https://asciidoctor.org/">Asciidoctor</a> with <a href="https://github.com/zajo/asciidoctor_skin">these customizations</a>.</p>
</div>
</div>
</div>
</div>
<div id="footnotes">
<hr>
<div class="footnote" id="_footnotedef_1">
<a href="#_footnoteref_1">1</a>. <a href="https://herbsutter.com/2007/01/24/questions-about-exception-specifications/" class="bare">https://herbsutter.com/2007/01/24/questions-about-exception-specifications/</a>
</div>
</div>
<div id="footer">
<div id="footer-text">
</div>
</div>
</body>
</html>